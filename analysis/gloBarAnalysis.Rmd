---
title: "GLOBAL BMU Analysis"
author: "ian enochs"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
#  pdf_document: default
#editor_options: 
#  chunk_output_type: console
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

This document was created to analyze NCRMP BMU data

# Load and clean data

```{r loadPackages, echo=FALSE}
# Core data stack
library(tidyverse)   # dplyr, ggplot2, tidyr, readr, purrr, tibble, stringr, forcats, magrittr
library(lubridate)
library(readxl)
library(jsonlite)
library(curl)
library(readr)

# Spatial
library(sf)          # vector
library(terra)       # raster/terra
library(units)
library(rnaturalearth)
library(rnaturalearthdata)
library(leaflet)
library(mapview)

# Viz helpers & layout
library(ggrepel)
library(ggpubr)
library(patchwork)
library(cowplot)
library(ggpubr)

# Stats / ecology
library(vegan)
library(cluster)
library(lme4)
library(lmerTest)
library(emmeans)


# Reporting
library(knitr)
library(kableExtra)
library(rmarkdown)
```

```{r setAesthetics, echo=FALSE}
# Create color scale for loc1.2 categories
loc_colors <- c(
  # Caribbean
    "caribbean.puertoRico"   = "#FFD34D",
    "caribbean.saintCroix"   = "#FF9B00",
    "caribbean.saintJohn"    = "#FF6B00",
    "caribbean.saintThomas"  = "#CC4E00",
  # Florida
    "florida.keys"           = "#660000",
    "florida.dryTortugas"    = "#E04B3B",
  # Flower Garden Banks 
    "flowerGardenBanks.flowerGardenBanks" = "#7B4F1D",
  # Marianas
    "marianas.guam"   = "#C51B7D",
    "marianas.maug"   = "#882E72",
    "marianas.pagan"  = "#5E4FA2",
    "marianas.saipan" = "#2A1E5C",
  # Middle Hawaiian Islands
    "middleHawaiianIslands.hawaii" = "#005B5A",
    "middleHawaiianIslands.oahu"   = "#4ED1C5",
  # Northwest Hawaiian Islands
    "northwestHawaiianIslands.frenchFrigateShoals" = "#004B9A",
    "northwestHawaiianIslands.pearlHermes"         = "#6FB6FF",
  # Pacific Remote Island Area
    "pacificRemoteIslandArea.jarvis"  = "#003B1A",
    "pacificRemoteIslandArea.palmyra" = "#1E8E3E",
    "pacificRemoteIslandArea.wake"    = "#7BC96F",
  # Samoa
    "samoa.ofu"     = "#1C1C1C",
    "samoa.tau"     = "#7A7A7A",
    "samoa.tutuila" = "#C8C8C8"
)

# Create box plot theme
myBoxplotStyle <- function(pal = loc_colors,
                    facet = vars(basin),
                    scales = "free_x", space = "free_x",
                    ylim = NULL, base = 12, xang = 90) {
  myBoxplotTheme <- theme_bw(base_size = base) + theme(
    plot.background = element_blank(),
    panel.grid = element_blank(),
    legend.position = "none",
    legend.title = element_blank(),
    panel.border = element_rect(fill = NA, color = "black"),
    axis.text.x = element_text(angle = xang, vjust = 0.5, hjust = 1)
  )
  c(
    list(
      myBoxplotTheme,
      geom_boxplot(color = "black",
        width = 0.6, 
        position = position_dodge2(preserve = "single")),
      geom_hline(yintercept = 0, linetype = "dashed", color = "red"),
      scale_fill_manual(values = pal),
      scale_x_discrete(name = ""),                           # always included
      facet_grid(cols = facet, scales = scales, space = space)
    ),
    if (!is.null(ylim)) list(coord_cartesian(ylim = ylim)) else list()
  )
}
```

```{r scatterPlotWrappers, echo=FALSE}
# Build labels for linear regression plots
.lm_label <- function(df, x, y) {
  sm <- summary(lm(as.formula(paste(y, "~", x)), data = df))
  sprintf("y = %.2f + %.3fx\nR² = %.2f   p = %.2g",
          coef(sm)[1,1], coef(sm)[2,1], sm$r.squared, coef(sm)[2,4])
}

# Helper: get p-value for slope term
.lm_p <- function(df, x, y) {
  if (nrow(df) < 2) return(NA_real_)
  sm <- summary(lm(as.formula(paste(y, "~", x)), data = df))
  sm$coefficients[2, 4]
}

# find group name match
.find_level <- function(vals, pattern) {
  u <- unique(vals)
  hit <- u[grepl(pattern, u, ignore.case = TRUE)]
  if (length(hit)) hit[1] else NA_character_
}

# build stacked label df
.build_labels <- function(df, x, y, group,
                          col_full = "black", col_atl = "red", col_pac = "blue") {
  out <- list()
  out[[length(out)+1]] <- data.frame(kind = "Full",
    label = paste0("Full: ", .lm_label(df, x, y)),
    col = col_full, vshift = 1)

  atl <- .find_level(df[[group]], "atlantic")
  if (!is.na(atl)) {
    sub <- df[df[[group]] == atl, ]
    if (nrow(sub) >= 2)
      out[[length(out)+1]] <- data.frame(kind = "Atlantic",
        label = paste0("Atlantic: ", .lm_label(sub, x, y)),
        col = col_atl, vshift = 2)
  }

  pac <- .find_level(df[[group]], "pacific")
  if (!is.na(pac)) {
    sub <- df[df[[group]] == pac, ]
    if (nrow(sub) >= 2)
      out[[length(out)+1]] <- data.frame(kind = "Pacific",
        label = paste0("Pacific: ", .lm_label(sub, x, y)),
        col = col_pac, vshift = 3)
  }
  do.call(rbind, out)
}

# Point-level scatter plot wrapper
plot_scatter_lm_full_atl_pac <- function(
  df, x, y, xlab, ylab, group = "basin",
  ylimits = NULL,
  col_full = "black", col_atl = "red", col_pac = "blue",
  lw_full = 1.2, lw_group = 0.9, alpha_group = 0.75,
  label_left = -Inf, label_top = Inf, label_spacing = 1.15,
  alpha_sig = 0.05
) {
  lbl <- .build_labels(df, x, y, group, col_full, col_atl, col_pac)

  p <- ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    # regression lines FIRST (drawn under points), only if significant
    {
      p_full <- .lm_p(df, x, y)
      if (!is.na(p_full) && p_full < alpha_sig)
        geom_smooth(aes(group = 1), method = "lm", se = TRUE,
                    color = col_full, linewidth = lw_full)
    } +
    {
      atl <- .find_level(df[[group]], "atlantic")
      if (!is.na(atl)) {
        sub <- df[df[[group]] == atl, ]
        if (nrow(sub) >= 2) {
          p_atl <- .lm_p(sub, x, y)
          if (!is.na(p_atl) && p_atl < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_atl, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    {
      pac <- .find_level(df[[group]], "pacific")
      if (!is.na(pac)) {
        sub <- df[df[[group]] == pac, ]
        if (nrow(sub) >= 2) {
          p_pac <- .lm_p(sub, x, y)
          if (!is.na(p_pac) && p_pac < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_pac, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    # points ON TOP
    geom_point(aes(color = factor(loc1.2), shape = .data[[group]]),
               size = 2, alpha = 0.8) +
    scale_color_manual(values = loc_colors) +
    labs(x = xlab, y = ylab) +
    theme_bw(base_size = 12) +
    theme(panel.grid = element_blank(),
          panel.border = element_rect(fill = NA, color = "black"),
          axis.text  = element_text(color = "black", size = 10),
          axis.title = element_text(color = "black", size = 11),
          legend.position = "none")

  if (!is.null(ylimits)) p <- p + coord_cartesian(ylim = ylimits)

  if (nrow(lbl))
    p <- p + geom_text(
      data = lbl,
      aes(x = label_left, y = label_top, label = label, colour = I(col),
          vjust = 1.05 + (vshift - 1) * label_spacing),
      inherit.aes = FALSE, hjust = -0.05, size = 3.9)

  p
}

# Loc2-level scatter plot wrapper
plot_loc2_lm_full_atl_pac <- function(
  df, x, y, sd_x, sd_y, xlab, ylab, group = "basin",
  ylimits = NULL,
  col_full = "black", col_atl = "red", col_pac = "blue",
  lw_full = 1.2, lw_group = 0.9, alpha_group = 0.75,
  label_left = -Inf, label_top = Inf, label_spacing = 1.15,
  alpha_sig = 0.05
) {
  lbl <- .build_labels(df, x, y, group, col_full, col_atl, col_pac)

  p <- ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    # regression lines FIRST, only if significant
    {
      p_full <- .lm_p(df, x, y)
      if (!is.na(p_full) && p_full < alpha_sig)
        geom_smooth(aes(group = 1), method = "lm", se = TRUE,
                    color = col_full, linewidth = lw_full)
    } +
    {
      atl <- .find_level(df[[group]], "atlantic")
      if (!is.na(atl)) {
        sub <- df[df[[group]] == atl, ]
        if (nrow(sub) >= 2) {
          p_atl <- .lm_p(sub, x, y)
          if (!is.na(p_atl) && p_atl < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_atl, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    {
      pac <- .find_level(df[[group]], "pacific")
      if (!is.na(pac)) {
        sub <- df[df[[group]] == pac, ]
        if (nrow(sub) >= 2) {
          p_pac <- .lm_p(sub, x, y)
          if (!is.na(p_pac) && p_pac < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_pac, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    # error bars
    geom_errorbar(aes(ymin = .data[[y]] - .data[[sd_y]],
                      ymax = .data[[y]] + .data[[sd_y]]), width = 0.1) +
    geom_errorbarh(aes(xmin = .data[[x]] - .data[[sd_x]],
                       xmax = .data[[x]] + .data[[sd_x]]), height = 0.1) +
    # points + site labels ON TOP
    geom_point(aes(color = factor(loc1.2), shape = .data[[group]]),
               size = 5, alpha = 0.8) +
    geom_text(aes(label = loc1.2), hjust = -0.1, vjust = -0.5,
              size = 3, color = "black") +
    scale_color_manual(values = loc_colors) +
    labs(x = xlab, y = ylab) +
    theme_bw(base_size = 12) +
    theme(panel.grid = element_blank(),
          panel.border = element_rect(fill = NA, color = "black"),
          axis.text  = element_text(color = "black", size = 10),
          axis.title = element_text(color = "black", size = 11),
          legend.position = "none")

  if (!is.null(ylimits)) p <- p + coord_cartesian(ylim = ylimits)

  if (nrow(lbl))
    p <- p + geom_text(
      data = lbl,
      aes(x = label_left, y = label_top, label = label, colour = I(col),
          vjust = 1.05 + (vshift - 1) * label_spacing),
      inherit.aes = FALSE, hjust = -0.05, size = 3.9)
  p
}

# Loc3-level scatter (labels = loc3, colors = loc1.2) using barStatsLoc3
plot_loc3_lm_full_atl_pac <- function(
  df, x, y, sd_x, sd_y, xlab, ylab, group = "basin",
  ylimits = NULL,
  col_full = "black", col_atl = "red", col_pac = "blue",
  lw_full = 1.2, lw_group = 0.9, alpha_group = 0.75,
  label_left = -Inf, label_top = Inf, label_spacing = 1.15,
  alpha_sig = 0.05
) {
  lbl <- .build_labels(df, x, y, group, col_full, col_atl, col_pac)

  p <- ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    # regression lines FIRST, only if significant
    {
      p_full <- .lm_p(df, x, y)
      if (!is.na(p_full) && p_full < alpha_sig)
        geom_smooth(aes(group = 1), method = "lm", se = TRUE,
                    color = col_full, linewidth = lw_full)
    } +
    {
      atl <- .find_level(df[[group]], "atlantic")
      if (!is.na(atl)) {
        sub <- df[df[[group]] == atl, ]
        if (nrow(sub) >= 2) {
          p_atl <- .lm_p(sub, x, y)
          if (!is.na(p_atl) && p_atl < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_atl, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    {
      pac <- .find_level(df[[group]], "pacific")
      if (!is.na(pac)) {
        sub <- df[df[[group]] == pac, ]
        if (nrow(sub) >= 2) {
          p_pac <- .lm_p(sub, x, y)
          if (!is.na(p_pac) && p_pac < alpha_sig)
            geom_smooth(data = sub,
                        aes(group = .data[[group]]), method = "lm", se = TRUE,
                        color = col_pac, alpha = alpha_group, linewidth = lw_group)
        }
      }
    } +
    # error bars
    geom_errorbar(aes(ymin = .data[[y]] - .data[[sd_y]],
                      ymax = .data[[y]] + .data[[sd_y]]), width = 0.1) +
    geom_errorbarh(aes(xmin = .data[[x]] - .data[[sd_x]],
                       xmax = .data[[x]] + .data[[sd_x]]), height = 0.1) +
    # points colored by loc1.2, labeled by loc3
    geom_point(aes(color = factor(loc1.2), shape = .data[[group]]),
               size = 5, alpha = 0.8) +
    geom_text(aes(label = loc3), hjust = -0.1, vjust = -0.5,
              size = 3, color = "black") +
    scale_color_manual(values = loc_colors) +
    labs(x = xlab, y = ylab) +
    theme_bw(base_size = 12) +
    theme(panel.grid = element_blank(),
          panel.border = element_rect(fill = NA, color = "black"),
          axis.text  = element_text(color = "black", size = 10),
          axis.title = element_text(color = "black", size = 11),
          legend.position = "none")

  if (!is.null(ylimits)) p <- p + coord_cartesian(ylim = ylimits)

  if (nrow(lbl))
    p <- p + geom_text(
      data = lbl,
      aes(x = label_left, y = label_top, label = label, colour = I(col),
          vjust = 1.05 + (vshift - 1) * label_spacing),
      inherit.aes = FALSE, hjust = -0.05, size = 3.9)
  p
}
```

```{r dataImportFunctionsAndPath, echo=FALSE}
# Attempt Ian's working directory first
rootFolder <- file.path("C:/Users/ian.enochs/Documents/GitHub/globalBar/analysis")

# If Ian's path does not exist, use John's path instead
if (!dir.exists(rootFolder)) {
  rootFolder <- file.path("/Users/john.morris/Documents/GitHub/globalBar/analysis")
}

setwd(rootFolder)
# Constants & Paths
rootFolder <- getwd()
##data_dir   <- file.path(rootFolder, "Github", "globalBar", "analysis", "data") #Original code
data_dir   <- file.path(rootFolder, "data")
atl_path   <- file.path(data_dir, "NCRMP_Atlantic_allBmuData.xlsx")
pac_path   <- file.path(data_dir, "NCRMP_Pacific_allBmuData.xlsx")
dec2025Update_path   <- file.path(data_dir, "Pac_Atl_NCRMP_2024_updateDec2025.xlsx") #dec2025 update path

##p_dir <- file.path(rootFolder, "Github", "globalBar", "analysis", "data", "parrotfish") #Original code
p_dir <- file.path(rootFolder, "data", "parrotfish")
atl_comm_path <- file.path(p_dir, "parrotfish_BMUs_Atlantic.csv")
pac_comm_path <- file.path(p_dir, "parrotfish_BMUs_Pacific.csv")
atl_fxn_path  <- file.path(p_dir, "parrotfishFXN_BMUs_Atlantic.csv")
pac_fxn_path  <- file.path(p_dir, "parrotfishFXN_BMUs_Pacific.csv")

##e_dir <- file.path(rootFolder, "Github", "globalBar", "analysis", "data", "environmental") #Original code
e_dir <- file.path(rootFolder, "data", "environmental")
env_path <- file.path(e_dir, "eds_time.csv")

# Helper: remove rows that are entirely NA (after making "" -> NA)
drop_all_na_rows <- function(df) {
  df %>%
    dplyr::mutate(dplyr::across(dplyr::where(is.character), ~ dplyr::na_if(trimws(.), ""))) %>%
    dplyr::filter(!dplyr::if_all(dplyr::everything(), ~ is.na(.)))
}

# Lookup helpers
to_basin <- function(region) dplyr::case_when(
  region %in% c("DRTO","FGB","FLK","PR","STJ","STT","STX") ~ "atlantic",
  region %in% c("MARIAN","MHI","NWHI","PRIA","SAMOA")      ~ "pacific",
  TRUE ~ NA_character_
)

to_loc1 <- function(region) dplyr::case_when(
  region %in% c("DRTO","FLK")           ~ "florida",
  region == "FGB"                       ~ "flowerGardenBanks",
  region %in% c("PR","STJ","STT","STX") ~ "caribbean",
  region == "MARIAN"                    ~ "marianas",
  region == "MHI"                       ~ "middleHawaiianIslands",
  region == "NWHI"                      ~ "northwestHawaiianIslands",
  region == "PRIA"                      ~ "pacificRemoteIslandArea",
  region == "SAMOA"                     ~ "samoa",
  TRUE ~ NA_character_
)

to_loc2 <- function(region, subRegion) dplyr::case_when(
  region == "DRTO" ~ "dryTortugas",
  region == "FGB"  ~ "flowerGardenBanks",
  region == "FLK"  ~ "keys",
  region == "PR"   ~ "puertoRico",
  region == "STJ"  ~ "saintJohn",
  region == "STT"  ~ "saintThomas",
  region == "STX"  ~ "saintCroix",
  subRegion == "OFU" ~ "ofu",
  subRegion == "PAL" ~ "palmyra",
  subRegion == "TAU" ~ "tau",
  subRegion == "TUT" ~ "tutuila",
  subRegion == "WAK" ~ "wake",
  subRegion == "JAR" ~ "jarvis",
  subRegion == "HAW" ~ "hawaii",
  subRegion == "OAH" ~ "oahu",
  subRegion == "FFS" ~ "frenchFrigateShoals",
  subRegion == "PHR" ~ "pearlHermes",
  subRegion == "GUA" ~ "guam",
  subRegion == "SAI" ~ "saipan",
  subRegion == "PAG" ~ "pagan",
  subRegion == "MAU" ~ "maug",
  TRUE ~ NA_character_
)

#loc3 logic
to_loc3 <- function(region, loc2, subRegion, siteName, basin, dataset_type, lat = NA_real_) {
  dtype <- tolower(dataset_type)   # "bar", "parrot", or "env"
  bsn   <- tolower(basin)
  sn    <- ifelse(is.na(siteName), "", siteName)
  site_norm <- gsub("_", "-", sn, fixed = TRUE)

  # helpers
  safe_concat <- function(l2, subR) {
    s <- ifelse(is.na(subR) | trimws(subR) == "", NA, subR)
    ifelse(is.na(s), l2, paste(l2, s, sep = "-"))
  }
  first3_letters_lower <- function(x) tolower(substr(gsub("\\s+", "", x), 1, 3))

  pac_dir_map <- c(
    # Tutuila
    "OCC-TUT-002"="north","OCC-TUT-007"="east","OCC-TUT-017"="south","OCC-TUT-022"="west",
    # Ofu
    "OCC-OFU-002"="north","OCC-OFU-009"="south",
    # Tau
    "OCC-TAU-002"="north","OCC-TAU-011"="west",
    # Jarvis
    "OCC-JAR-003"="east","OCC-JAR-008"="south","OCC-JAR-013"="west",
    # Palmyra
    "OCC-PAL-003"="north","OCC-PAL-008"="east","OCC-PAL-017"="west",
    # Hawaii
    "OCC-HAW-014"="north","OCC-HAW-002"="north","OCC-HAW-006"="east","OCC-HAW-066"="east","OCC-HAW-008"="south","OCC-HAW-010"="west",#note east is listed as 066 in parrotfish and 006 in bar
    # Oahu
    "OCC-OAH-002"="north","OCC-OAH-005"="east","OCC-OAH-007"="east","OCC-OAH-008"="southeast", "OCC-OAH-009"="south","OCC-OAH-010"="south","OCC-OAH-014"="southwest","OCC-OAH-012"="west",#note 009 doesn't exist
    # FFS
    "OCC-FFS-002"="north","OCC-FFS-004"="north","OCC-FFS-007"="east","OCC-FFS-010"="south","OCC-FFS-014"="west",
    # Pearl & Hermes
    "OCC-PHR-002"="north","OCC-PHR-016"="west",                  "OCC-PHR-007"="east","OCC-PHR-012"="south",
    # Wake
    "OCC-WAK-002"="north","OCC-WAK-005"="east","OCC-WAK-008"="south","OCC-WAK-013"="west",
    # Guam
    "OCC-GUA-002"="north","OCC-GUA-005"="east","OCC-GUA-009"="south","OCC-GUA-015"="west",
    # Saipan
    "OCC-SAI-002"="north","OCC-SAI-005"="east","OCC-SAI-009"="south","OCC-SAI-012"="west","OCC-SAI-016"="northwest",
    # Pagan
    "OCC-PAG-002"="north","OCC-PAG-006"="east","OCC-PAG-009"="south","OCC-PAG-013"="west",
    # Maug
    "OCC-MAU-002"="north","OCC-MAU-005"="east","OCC-MAU-019"="south","OCC-MAU-008"="west","OCC-MAU-016"="innerHCO2","OCC-MAU-018"="innerMCO2"
  )

  # ENV-only helpers (lat -> loc3)
  env_lat_map <- c(
    # puerto rico
    "18.48227"="north","18.33066"="east","18.33696"="northeast","17.91047"="south","17.95355"="southwest","18.34435"="west",
    # saint croix
    "17.82805"="east","17.78532"="north","17.70121"="south","17.7338"="west",
    # saint john
    "18.36316"="north","18.34744"="east","18.32802"="west","18.30976"="south",
    # saint thomas
    "18.34402"="south","18.38262"="north","18.34082"="west",
    # dry tortugas
    "24.61123"="west",
    # florida keys
    "24.5859"="lki","24.57899"="lki","24.52202"="lko","24.55326"="lko","24.68554"="mki","24.68988"="mki","24.63127"="mko","24.63388"="mko","24.95375"="uki","24.9025"="uko","24.88266"="uko","24.89742"="uki",
    # flower garden banks
    "27.9074"="east",
    # guam
    "13.6033"="north","13.47516"="east","13.24126"="south","13.2421"="OCC-GUA-009","13.52894"="west",
    # maug
    "20.0357"="north","20.02033"="east","20.01312"="west","20.02296"="innerHCO2","20.02249"="innerMCO2","20.01398"="south",
    # pagan
    "18.16784"="north","18.09612"="east","18.04564"="south","18.12014"="west",
    # saipan
    "15.29062"="north","15.25866"="east","15.09785"="south","15.15639"="OCC-SAI-012","15.15645"="west","15.25719"="northwest",
    # hawaii
    "20.26828"="north","20.24913"="north","19.48642"="east", "19.06075"="south", "19.24432"="west",
    # oahu
    "21.45862"="east","21.47972"="east","21.28838"="south","21.26184"="southeast","21.53412"="west","21.30566"="southwest",
    # french frigate shoals
    "23.87806"="north","23.88021"="north","23.83515"="east","23.63686"="south","23.79247"="west",
    # pearl and hermes
    "27.94055"="north","27.95493"="north","27.86679"="east","27.78237"="south","27.79316"="OCC-PHR-016",
    # jarvis
    "-0.36896"="west","-0.38234"="south",
    # palmyra
    "5.89733"="north","5.86379"="east","5.88322"="west",
    # wake
    "19.31602"="north","19.30616"="east","19.28065"="south","19.31625"="west",
    # ofu
    "-14.15785"="north","-14.1733"="south",
    # tau
    "-14.2124"="north","-14.25755"="west",
    # tutuila
    "-14.24479"="north","-14.28521"="east","-14.36351"="south","-14.29464"="west"
  )
  env_loc3_from_lat <- function(lat) {
    key <- as.character(round(lat, 5))
    out <- unname(env_lat_map[key])
    ifelse(is.na(out), NA_character_, out)
  }

  # ENV branch
  if (dtype == "env") {
    return(env_loc3_from_lat(lat))
  }

  # BAR/PARROT branches
  targets_atl_concat <- c("dryTortugas","flowerGardenBanks","puertoRico","saintJohn","saintThomas","saintCroix")

  dplyr::case_when(
    # --- SPECIFIC OVERRIDES MUST COME FIRST ---

    # Puerto Rico corrections (normalized site names)
    dtype == "parrot" &  loc2 == "puertoRico" & siteName == "fajardo" & subRegion == "east"    ~ "puertoRico-northeast",
    dtype == "parrot" & loc2 == "puertoRico" & siteName == "fajardo" & subRegion == "north"    ~ "puertoRico-north",
    dtype == "parrot" & loc2 == "puertoRico" & siteName == "culebra" & subRegion == "east"    ~ "puertoRico-east",
    dtype == "bar" & loc2 == "puertoRico" & siteName == "Fajardo"    ~ "puertoRico-northeast",
    
        
    bsn == "atlantic" & loc2 == "puertoRico" & siteName == "laParguera" ~ "puertoRico-southwest",
    bsn == "atlantic" & loc2 == "puertoRico" & siteName == "La Parguera" ~ "puertoRico-southwest",

    bsn == "atlantic" & loc2 == "puertoRico" & siteName == "laParguera" ~ "puertoRico-southwest",

    # PACIFIC specific map (by siteName code) and fallback
    bsn == "pacific" & site_norm %in% names(pac_dir_map) ~ paste(loc2, pac_dir_map[site_norm], sep = "-"),
    bsn == "pacific"                                     ~ loc2,

    # ATLANTIC general concat AFTER specific overrides
    bsn == "atlantic" & loc2 %in% targets_atl_concat     ~ safe_concat(loc2, subRegion),

    # KEYS special cases
    bsn == "atlantic" & loc2 == "keys" & dtype == "bar"  ~ paste(
      loc2,
      ifelse(first3_letters_lower(site_norm) == "che", "uki", first3_letters_lower(site_norm)),
      sep = "-"
    ),
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "lower"  & site_norm == "inshore"  ~ "keys-lki",
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "lower"  & site_norm == "offshore" ~ "keys-lko",
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "middle" & site_norm == "inshore"  ~ "keys-mki",
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "middle" & site_norm == "offshore" ~ "keys-mko",
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "upper"  & site_norm == "inshore"  ~ "keys-uki",
    bsn == "atlantic" & loc2 == "keys" & dtype == "parrot" & subRegion == "upper"  & site_norm == "offshore" ~ "keys-uko",

    TRUE ~ NA_character_
  )
}
```

```{r loadData, echo=FALSE}
# Read & Bind BAR data
# Column specs (Parrot CSVs)
ct <- cols(
  .default       = col_guess(),
  yearFishSurvey = col_integer(),
  siteFishSurvey = col_character()
)
# ---- readers ----
# For CSVs
read_bind_csv <- function(paths, col_types) {
  purrr::map_dfr(paths, ~ readr::read_csv(.x, col_types = col_types, show_col_types = FALSE))
}

# For Excel (.xlsx)
read_bind_excel <- function(paths, sheet = NULL) {
  purrr::map_dfr(
    paths,
    ~ readxl::read_excel(.x, sheet = sheet)
  )
}
# Read & Bind Bar Data
barData_raw <-
  read_bind_excel(c(atl_path, pac_path, dec2025Update_path)) %>%
  drop_all_na_rows()
# Read & Bind Parrot Community Data
parrotCommunityData <- read_bind_csv(c(atl_comm_path, pac_comm_path), ct) %>%
  drop_all_na_rows()
# Read & Bind Parrot FXN Data
parrotFXNData <- read_bind_csv(c(atl_fxn_path, pac_fxn_path), ct) %>%
  drop_all_na_rows()

environmentalData_raw <- read_bind_csv(c(env_path), cols(.default = col_guess())) %>%
  drop_all_na_rows()
```

```{r QAQC, echo=FALSE}
#Fix typos in raw data
barData_raw <- barData_raw %>%
  mutate(
    siteName = case_when(
      siteName == "OCC-HAW-10" ~ "OCC-HAW-010",
      siteName == "OCC-OAH-012" & as.character(tagNum) == "1660" ~ "OCC-OAH-002",
      siteName == "OCC-JAR-003" & tagNum %in% c(3265, 3266, 3267, 3268) ~ "OCC-JAR-013",
      TRUE ~ siteName
          )
  )
```

```{r creatLocFields, echo=FALSE}
# Create loc fields
# ===== BAR =====
barData <- barData_raw %>%
  select(-c(dimensions, carbMDPre, carbEQPre, carbMDPost)) %>%
  mutate(
    daysDeployed  = as.numeric(ymd(dateRecovery) - ymd(dateDeployment)),
    yearsDeployed = daysDeployed / 365
  ) %>%
  mutate(
    basin = to_basin(region),
    loc1  = to_loc1(region),
    loc2  = to_loc2(region, subRegion),
    loc3  = to_loc3(region, loc2, subRegion, siteName, basin, dataset_type = "bar"),
    loc1.2 = paste(loc1, loc2, sep = ".")
  )

# ===== Parrot community =====
parrotCommunityData <- parrotCommunityData %>%
  mutate(
    basin = to_basin(region),
    loc1  = to_loc1(region),
    loc2  = to_loc2(region, subRegion),
    loc3  = to_loc3(region, loc2, subRegion, siteName, basin, dataset_type = "parrot"),
    loc1.2 = paste(loc1, loc2, sep = ".")
  )

# ===== Parrot functional groups =====
parrotFXNData <- parrotFXNData %>%
  mutate(
    basin = to_basin(region),
    loc1  = to_loc1(region),
    loc2  = to_loc2(region, subRegion),
    loc3  = to_loc3(region, loc2, subRegion, siteName, basin, dataset_type = "parrot"),
    loc1.2 = paste(loc1, loc2, sep = ".")
  )  

# ===== Environmental data =====
environmentalData <- environmentalData_raw %>%
  mutate(
    loc3   = paste(loc2, (to_loc3(loc1, loc2, subRegion,
                     siteName = NA_character_, basin = basin,
                     dataset_type = "env", lat = lat)), sep = "-"),
    loc1.2 = paste(loc1, loc2, sep = ".")
  )


```

```{r calculateBarRates, echo=FALSE}
# Derived metrics (area/time standardized)
preSA <- 24  # cm^2 exterior-facing bar (2 x 1 x 5 cm block)
barData <- barData %>%
  mutate(
    grazing                = volumeBlockPost - macroboring - volumeBlockPre,
    deltaMass_mgcm2y       = 1000 * (massCleanPost - massEpoxiedPre) / preSA / yearsDeployed,
    deltaMass_kgm2y        = 0.01 * 1000 * (massCleanPost - massEpoxiedPre) / preSA / yearsDeployed,
    deltaVolume_mm3cm2y    = 1000 * (volumeBlockPost + accretion - volumeBlockPre) / preSA / yearsDeployed,
    deltaDensity_mgcm3cm2y = 1000 * (densityCTPost - densityCTPre) / preSA / yearsDeployed,
    macroboring_mm3cm2y    = 1000 * macroboring / preSA / yearsDeployed,
    accretion_mm3cm2y      = 1000 * accretion   / preSA / yearsDeployed,
    grazing_mm3cm2y        = 1000 * grazing     / preSA / yearsDeployed
  )
```

### Identify and remove bars with NA's (except those in density)
```{r dealWithNAs, echo=FALSE}
# =========================
# Config
# =========================
vars <- c(
  "deltaMass_mgcm2y",
  "deltaVolume_mm3cm2y",
  "deltaDensity_mgcm3cm2y",
  "macroboring_mm3cm2y",
  "grazing_mm3cm2y"
)

# Ensure a consistent tag column (supports either tagNum or tagnum)
barData1 <- barData %>%
  mutate(tag = coalesce(.data[["tagNum"]], .data[["tagNum"]])) %>%
  # keep just what we need
  select(tag, all_of(vars))

# =========================
# (1) NA Table by Bar Tag (wide)
# =========================
# For each variable, mark "NA" where the value is missing, "" otherwise.
na_table <- barData1 %>%
  mutate(across(all_of(vars), ~ if_else(is.na(.x), "NA", ""), .names = "{.col}")) %>%
  # keep only rows with at least one NA among the key variables
  filter(if_any(all_of(vars), ~ .x == "NA")) %>%
  arrange(tag)

# Show the NA table
pretty_names <- names(na_table)
pretty_names[pretty_names == "tag"] <- "Bar tag"

na_table %>%
  # keep blanks slim but visible in HTML (so they don't collapse)
  dplyr::mutate(dplyr::across(all_of(vars), ~ ifelse(. == "", "&nbsp;", .))) %>%
  kbl(
    escape    = FALSE,              # allow the &nbsp;
    col.names = pretty_names,
    booktabs  = TRUE,
    align     = "l",
    caption   = "Bars with missing values (by variable)"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "condensed", "hover"),
    full_width        = FALSE,
    position          = "left",
    fixed_thead       = TRUE        # sticky header
  ) %>%
  scroll_box(height = "420px", width = "100%")

# Count bars before removal
before_n <- nrow(barData)

# Identify bars that would be removed (NA in any variable except density)
bars_to_remove <- barData %>%
  filter(if_any(all_of(vars[vars != "deltaDensity_mgcm3cm2y"]), is.na))

remove_n <- nrow(bars_to_remove)
cat("Bars to remove due to NA (excluding density):", remove_n, "\n")

# Remove bars ONLY if NA is present in any variable EXCEPT density
barData <- barData %>%
  drop_na(all_of(vars[vars != "deltaDensity_mgcm3cm2y"]))
```

### Graph response distributions, remove bar outliers over 3sd
```{r dealWithOutliers, echo=FALSE}
# =========================
# (2) Multipanel histograms with ±3 SD highlighting
# =========================
long_df <- barData %>% ###JTM Note: changed from barData1 to barData to run outlier identification on NA filtered dataset
  pivot_longer(cols = all_of(vars), names_to = "variable", values_to = "value") %>%
  filter(!is.na(value)) %>%
  group_by(variable) %>%
  mutate(
    mu  = mean(value, na.rm = TRUE),
    sdv = sd(value,   na.rm = TRUE),
    lower = mu - 3 * sdv,   # <-- CHANGED
    upper = mu + 3 * sdv,   # <-- CHANGED
    outlier = value < lower | value > upper
  ) %>%
  ungroup()

ggplot(long_df, aes(x = value, fill = outlier)) +
  geom_histogram(bins = 30, color = "black") +
  scale_fill_manual(values = c(`FALSE` = "grey80", `TRUE` = "red"),
                    name = "Outside ±3 SD") +  # <-- CHANGED
  facet_wrap(~ variable, scales = "free", ncol = 2) +
  labs(
    title = "QA/QC Histograms of BAR Variables",
    x = NULL, y = "Frequency"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "top")

# =========================
# (2A) Table of outliers (values beyond ±3 SD)
# =========================
outlier_table <- barData %>% ###JTM Note: changed from barData1 to barData to run outlier identification on NA filtered dataset
  mutate(tag = .data[["tagNum"]]) %>% #Added this line based on above note
  pivot_longer(cols = all_of(vars), names_to = "variable", values_to = "value") %>%
  group_by(variable) %>%
  mutate(
    mu  = mean(value, na.rm = TRUE),
    sdv = sd(value, na.rm = TRUE),
    lower = mu - 3 * sdv,   # <-- CHANGED
    upper = mu + 3 * sdv,   # <-- CHANGED
    outlier_value = if_else(value < lower | value > upper, as.character(value), "")
  ) %>%
  ungroup() %>%
  select(tag, variable, outlier_value) %>%
  pivot_wider(names_from = variable, values_from = outlier_value) %>%
  filter(if_any(all_of(vars), ~ .x != "")) %>%
  arrange(tag)

pretty_names_out <- names(outlier_table)
pretty_names_out[pretty_names_out == "tag"] <- "Bar tag"

outlier_table %>%
  mutate(across(all_of(vars), ~ ifelse(. == "", "&nbsp;", .))) %>%
  kbl(
    escape    = FALSE,
    col.names = pretty_names_out,
    booktabs  = TRUE,
    align     = "l",
    caption   = "Values Outside ±3 SD (by variable)"  # <-- CHANGED
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "condensed", "hover"),
    full_width        = FALSE,
    position          = "left",
    fixed_thead       = TRUE
  ) %>%
  scroll_box(height = "420px", width = "100%")


cat("Bars to remove due to ±3 SD outliers:", dplyr::n_distinct(outlier_table$tag), "\n")

# filter out outliers
barData <- barData %>%
  filter(!tagNum %in% outlier_table$tag)
```

### Graph deployment duration
```{r deploymentHistogram, include=FALSE}
# =========================
# Histogram of duration with ±3 SD highlighting
# =========================
durationDistribution <- ggplot(barData, aes(x = duration)) +
  geom_histogram(bins = 30, color = "black", fill = "grey80") +
  labs(
    title = "Distribution of Duration",
    x = "Duration",
    y = "Frequency"
  ) +
  theme_minimal(base_size = 12)
durationDistribution

## Regression of deployment distribution
lm_model_deltaMassVsDays <- lm(deltaMass_mgcm2y ~ daysDeployed, data = barData)
r_squared_deltaMassVsDays <- summary(lm_model_deltaMassVsDays)$r.squared
plotDeltaMassVsDays <- ggplot(barData, aes(x = daysDeployed, y = deltaMass_mgcm2y)) +
  geom_point(aes(color = factor(loc1.2)))+  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal() +
  scale_color_manual(values = loc_colors) +
  geom_text(data = subset(barData, daysDeployed > 2500), aes(label = tagNum), hjust = -0.1, vjust = -0.5, size = 2)+# Add tag numbers here where days deployed is greater than 2500
  geom_text(data = subset(barData, deltaMass_mgcm2y > 100), aes(label = tagNum), hjust = -0.1, vjust = -0.5, size = 2)+# Add tag numbers here where delta mass is greater than 100
  geom_text(x = 2000, y = 100, label = paste("R^2 =", round(r_squared_deltaMassVsDays, 5)), size = 3)
#Plot of deltaVolume_mm3cm2y vs. daysDeployed:
lm_model_deltaVolumeVsDays <- lm(deltaVolume_mm3cm2y ~ daysDeployed, data = barData)
r_squared_deltaVolumeVsDays <- summary(lm_model_deltaVolumeVsDays)$r.squared
plotDeltaVolumeVsDays <- ggplot(barData, aes(x = daysDeployed, y = deltaVolume_mm3cm2y)) +
  geom_point(aes(color = factor(loc1.2))) +  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal()+
  scale_color_manual(values = loc_colors) +
  geom_text(x = 2000, y = -30, label = paste("R^2 =", round(r_squared_deltaVolumeVsDays, 5)), size = 3)
#Plot of deltaDensity_mgcm3cm2y vs. daysDeployed:
lm_model_deltaDensityVsDays <- lm(deltaDensity_mgcm3cm2y ~ daysDeployed, data = barData)
r_squared_deltaDensityVsDays <- summary(lm_model_deltaDensityVsDays)$r.squared
plotDeltaDensityVsDays <- ggplot(barData, aes(x = daysDeployed, y = deltaDensity_mgcm3cm2y)) +
  geom_point(aes(color = factor(loc1.2))) +  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal()+
  scale_color_manual(values = loc_colors) +
  geom_text(x = 2000, y = -5, label = paste("R^2 =", round(r_squared_deltaDensityVsDays, 5)), size = 3)
#Plot of macroboring_mm3cm2y vs. daysDeployed:
lm_model_macroboringVsDays <- lm(macroboring_mm3cm2y ~ daysDeployed, data = barData)
r_squared_macroboringVsDays <- summary(lm_model_macroboringVsDays)$r.squared
plotMacroboringVsDays <- ggplot(barData, aes(x = daysDeployed, y = macroboring_mm3cm2y)) +
  geom_point(aes(color = factor(loc1.2))) +  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal()+
  scale_color_manual(values = loc_colors) +
  geom_text(x = 2000, y = -30, label = paste("R^2 =", round(r_squared_macroboringVsDays, 5)), size = 3)
#Plot of grazing_mm3cm2y vs. daysDeployed:
lm_model_grazingVsDays <- lm(grazing_mm3cm2y ~ daysDeployed, data = barData)
r_squared_grazingVsDays <- summary(lm_model_grazingVsDays)$r.squared
plotGrazingVsDays <- ggplot(barData, aes(x = daysDeployed, y = grazing_mm3cm2y)) +
  geom_point(aes(color = factor(loc1.2))) +  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal()+
  scale_color_manual(values = loc_colors) +
  geom_text(x = 2000, y = -75, label = paste("R^2 =", round(r_squared_grazingVsDays, 2)), size = 3)
#Plot of accretion_mm3cm2y vs. daysDeployed:
lm_model_accretionVsDays <- lm(accretion_mm3cm2y ~ daysDeployed, data = barData)
r_squared_accretionVsDays <- summary(lm_model_accretionVsDays)$r.squared
plotAccretionVsDays <- ggplot(barData, aes(x = daysDeployed, y = accretion_mm3cm2y)) +
  geom_point(aes(color = factor(loc1.2))) +  # Scatterplot
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  theme_minimal()+
  scale_color_manual(values = loc_colors) +
  geom_text(x = 2000, y = 100, label = paste("R^2 =", round(r_squared_accretionVsDays, 2)), size = 3)
ggarrange(plotDeltaMassVsDays,plotDeltaVolumeVsDays,plotDeltaDensityVsDays,plotMacroboringVsDays,plotGrazingVsDays,plotAccretionVsDays, ncol = 3, nrow = 2, common.legend = TRUE, legend = "bottom")
```

### Clean data
Remove data that is
1. Not successfully recovered
2. Not plob or mcav
3. Tag 1022
4. Data from Maug seep
5. Grazing data that is positive
6. Deployed for more than 6 years or less than 2 years
```{r cleanData, echo=FALSE}
barData <- barData %>%
  filter(fate == "SUCCESSFULLY RECOVERED",
         species != "Isopora sp.",
         tagNum != 1022,
         loc3 != "maug-innerMCO2",
         loc3 != "maug-innerHCO2",
         grazing_mm3cm2y<0,
         duration<6,
         duration>2)
```

### Remove sites with low replication
```{r removeLowReplication, echo=FALSE}
use_loc_level <- 3        # set to 2 or 3
min_reps      <- 3        # keep sites with >= min_reps; remove if n_bar < min_reps

# Resolve the location column symbol (loc2 or loc3)
loc_col <- rlang::sym(paste0("loc", use_loc_level))

# =========================
# 1) Counts and removal list (including zeros)
# =========================
bar_counts <- barData %>%
  dplyr::count(!!loc_col, name = "n_bar") %>%
  dplyr::rename(site = !!loc_col)

parrot_counts <- parrotCommunityData %>%
  dplyr::count(!!loc_col, name = "n_parrot_comm") %>%
  dplyr::rename(site = !!loc_col)

fxn_counts <- parrotFXNData %>%
  dplyr::count(!!loc_col, name = "n_parrot_fxn") %>%
  dplyr::rename(site = !!loc_col)

# Union of all sites appearing in ANY dataset used downstream
all_sites <- union(
  barData %>% dplyr::pull(!!loc_col),
  union(
    parrotCommunityData %>% dplyr::pull(!!loc_col),
    parrotFXNData %>% dplyr::pull(!!loc_col)
  )
)

# Build removal list where BAR replication < min_reps (0 included)
removal_df <- tibble::tibble(site = all_sites) %>%
  dplyr::left_join(bar_counts,   by = "site") %>%
  dplyr::mutate(n_bar = dplyr::coalesce(n_bar, 0L)) %>%
  dplyr::left_join(parrot_counts, by = "site") %>%
  dplyr::mutate(n_parrot_comm = dplyr::coalesce(n_parrot_comm, 0L)) %>%
  dplyr::left_join(fxn_counts, by = "site") %>%
  dplyr::mutate(n_parrot_fxn = dplyr::coalesce(n_parrot_fxn, 0L)) %>%
  dplyr::filter(n_bar < min_reps) %>%
  dplyr::arrange(n_bar, dplyr::desc(n_parrot_comm), dplyr::desc(n_parrot_fxn))

# =========================
# 2) Display table of removed sites
# =========================
cat(sprintf("### loc%d removed due to insufficient replication (< %d BARs)\n",
            use_loc_level, min_reps))
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(removal_df)
} else {
  print(removal_df)
}

# =========================
# Count total bars & removal summary
# =========================
total_bars_before <- nrow(barData)

bars_to_remove <- barData %>%
  dplyr::filter(!!loc_col %in% removal_df$site)

total_removed <- nrow(bars_to_remove)
percent_removed <- round((total_removed / total_bars_before) * 100, 1)

cat("Total BARs before filtering:", total_bars_before, "\n")
cat("Total BARs removed:", total_removed, "\n")
cat("Percent removed:", percent_removed, "%\n\n")

# =========================
# 3) Filter all datasets using the removal list
# =========================
barData <- barData %>%
  dplyr::filter(!(!!loc_col %in% removal_df$site))

parrotCommunityData <- parrotCommunityData %>%
  dplyr::filter(!(!!loc_col %in% removal_df$site))

parrotFXNData <- parrotFXNData %>%
  dplyr::filter(!(!!loc_col %in% removal_df$site))

environmentalData <- environmentalData %>%
  dplyr::filter(!(!!loc_col %in% removal_df$site))
```

### Check binds across datasets
```{r checkBinds, echo=FALSE}
# ===== Function (general 3-way compare) =====
compare_loc <- function(df_bar, df_parrot, df_env, loc_col) {
  join_col <- rlang::as_name(rlang::ensym(loc_col))

  full_join(
    df_bar    %>% distinct({{loc_col}}) %>% mutate(in_BAR = TRUE),
    df_parrot %>% distinct({{loc_col}}) %>% mutate(in_PARROT = TRUE),
    by = join_col
  ) %>%
    full_join(
      df_env %>% distinct({{loc_col}}) %>% mutate(in_ENV = TRUE),
      by = join_col
    ) %>%
    # Any missing membership flags become FALSE
    mutate(across(starts_with("in_"), ~ tidyr::replace_na(., FALSE))) %>%
    mutate(
      match_status = case_when(
        in_BAR & in_PARROT & in_ENV                  ~ "MATCH",
        in_BAR & in_PARROT & !in_ENV                 ~ "BAR & PARROT only",
        in_BAR & in_ENV    & !in_PARROT              ~ "BAR & ENV only",
        in_PARROT & in_ENV & !in_BAR                 ~ "PARROT & ENV only",
        in_BAR    & !in_PARROT & !in_ENV            ~ "ONLY in BAR",
        in_PARROT & !in_BAR    & !in_ENV            ~ "ONLY in PARROT",
        in_ENV    & !in_BAR    & !in_PARROT         ~ "ONLY in ENV",
        TRUE                                          ~ "UNKNOWN"
      )
    ) %>%
    arrange({{loc_col}})
}

# ===== Function (original 2-way BAR vs PARROT only) =====
compare_loc_2way <- function(df_bar, df_parrot, loc_col) {
  join_col <- rlang::as_name(rlang::ensym(loc_col))

  full_join(
    df_bar    %>% distinct({{loc_col}}) %>% mutate(in_BAR = TRUE),
    df_parrot %>% distinct({{loc_col}}) %>% mutate(in_PARROT = TRUE),
    by = join_col
  ) %>%
    mutate(across(starts_with("in_"), ~ tidyr::replace_na(., FALSE))) %>%
    mutate(
      match_status = case_when(
        in_BAR & in_PARROT  ~ "MATCH",
        in_BAR & !in_PARROT ~ "ONLY in BAR",
        !in_BAR & in_PARROT ~ "ONLY in PARROT",
        TRUE                ~ "UNKNOWN"
      )
    ) %>%
    arrange({{loc_col}})
}

# ===== Run comparisons =====
loc1_compare <- compare_loc(barData, parrotCommunityData, environmentalData, loc1)
loc2_compare <- compare_loc(barData, parrotCommunityData, environmentalData, loc2)
loc3_compare <- compare_loc(barData, parrotCommunityData, environmentalData, loc3)  # <-- now 3-way

# ===== View results =====
kable(loc1_compare, caption = "loc1 Comparison: BAR vs PARROT vs ENV")
kable(loc2_compare, caption = "loc2 Comparison: BAR vs PARROT vs ENV")
kable(loc3_compare, caption = "loc3 Comparison: BAR vs PARROT vs ENV")
```

# Data exploration
## General
### Map of BAR, parrot surveys, and environmental sites
```{r, echo=FALSE}
barSiteMap <- leaflet() %>%
  addProviderTiles(providers$CartoDB.PositronNoLabels) %>%

  # ===== BAR DATA =====
  addCircleMarkers(
    data = barData,
    lng = ~longitude, lat = ~latitude,
    radius = 2, color = "blue",
    label = ~paste0(loc3),
    labelOptions = labelOptions(
      noHide = TRUE,
      direction = "top",
      textsize = "12px",
      offset = c(0, -4)
    )
  ) %>%

  # ===== PARROTFISH DATA =====
  addCircleMarkers(
    data = parrotCommunityData,
    lng = ~longitudeFishSurvey, lat = ~latitudeFishSurvey,
    radius = 1, color = "red",
    popup = ~paste0(loc3)   
  )   %>%

  # ===== ENVIRONMENTAL DATA (COMMENTED OUT) =====

  addCircleMarkers(
    data = environmentalData,
    lng = ~lon, lat = ~lat,
    radius = 1, color = "green",
    popup = ~paste0(loc3,",",lat,",",lon)   
  )

barSiteMap
```

### Timeline of BAR data, parrot surveys, and environmental data
```{r, echo=FALSE}
# -----------------------------
# 0) Appearance knobs (tweak as desired)
# -----------------------------
tick_h        <- 0.18  # half-height of deploy/recover vertical ticks
sst_y_offset  <- 0.25  # SST dots sit this far below the site line
chl_y_offset  <- 0.35  # chlorophyll dots sit slightly further down
sst_col       <- "mean_Sea_Surface_Temperature_CRW_daily_01mo"  # <— your SST column

# Helper: pick a likely chlorophyll column if you don't want to hardcode it
pick_chl_col <- function(df) {
  cols <- names(df)
  cand <- cols[grepl("chlor|chla|chl_a|chlorophyll", cols, ignore.case = TRUE)]
  # prefer "mean" if present
  cand <- c(cand[grepl("mean", cand, ignore.case = TRUE)],
            setdiff(cand, cand[grepl("mean", cand, ignore.case = TRUE)]))
  if (length(cand)) cand[1] else NA_character_
}

# If you prefer to hardcode a chlorophyll column, set it here (uncomment & edit):
# chl_col <- "mean_Chlorophyll_MODIS_daily_01mo"
chl_col <- pick_chl_col(environmentalData)

# -----------------------------
# 1) Timeline data (deploy/recover)
# -----------------------------
timeline_df <- barData %>%
  mutate(
    deploy  = ymd(dateDeployment),
    recover = ymd(dateRecovery)
  ) %>%
  filter(!is.na(loc1.2), !is.na(deploy), !is.na(recover)) %>%
  mutate(
    start = pmin(deploy, recover, na.rm = TRUE),
    end   = pmax(deploy, recover, na.rm = TRUE)
  ) %>%
  group_by(loc1.2) %>%
  arrange(start, .by_group = TRUE) %>%
  ungroup()

# order sites by first deployment and freeze that order
site_levels <- timeline_df %>%
  group_by(loc1.2) %>%
  summarise(first_start = min(start, na.rm = TRUE), .groups = "drop") %>%
  arrange(first_start) %>%
  pull(loc1.2)

timeline_df <- timeline_df %>%
  mutate(
    loc1.2 = factor(loc1.2, levels = site_levels),
    y_num  = as.numeric(loc1.2)
  )

# -----------------------------
# 2) Parrot survey data (black points, mid-year)
# -----------------------------
survey_df <- parrotCommunityData %>%
  filter(!is.na(loc1.2), !is.na(yearFishSurvey)) %>%
  mutate(
    year_date = ymd(paste0(as.character(yearFishSurvey), "-07-01")),
    loc1.2    = factor(loc1.2, levels = site_levels),
    y_num     = as.numeric(loc1.2)
  ) %>%
  filter(!is.na(year_date), !is.na(y_num))

# -----------------------------
# 3) Environmental SST (light red dots) — date is DMY
# -----------------------------
sst_df <- environmentalData %>%
  mutate(
    date   = dmy(date),             # <-- your environmentalData date format
    sstval = .data[[sst_col]],
    loc1.2 = factor(loc1.2, levels = site_levels),
    y_num  = as.numeric(loc1.2)
  ) %>%
  filter(!is.na(loc1.2), !is.na(date), !is.na(sstval), !is.na(y_num))

# -----------------------------
# 4) Environmental Chlorophyll (light green dots) — date is DMY
# -----------------------------
chl_df <- environmentalData %>%
  mutate(
    date   = dmy(date),
    chlval = if (!is.na(chl_col)) .data[[chl_col]] else NA_real_,
    loc1.2 = factor(loc1.2, levels = site_levels),
    y_num  = as.numeric(loc1.2)
  ) %>%
  filter(!is.na(loc1.2), !is.na(date), !is.na(chlval), !is.na(y_num))

# -----------------------------
# 5) Plot
# -----------------------------
p_timeline <- ggplot() +
  # Grey bar: deployment → recovery
  geom_segment(
    data = timeline_df,
    aes(x = start, xend = end, y = y_num, yend = y_num),
    linewidth = 3, lineend = "round", color = "grey50"
  ) +
  # Deployment tick (green)
  geom_segment(
    data = timeline_df,
    aes(x = start, xend = start, y = y_num - tick_h, yend = y_num + tick_h),
    linewidth = 0.9, color = "forestgreen"
  ) +
  # Recovery tick (red)
  geom_segment(
    data = timeline_df,
    aes(x = end, xend = end, y = y_num - tick_h, yend = y_num + tick_h),
    linewidth = 0.9, color = "firebrick"
  ) +
  # Parrot survey years (black)
  geom_point(
    data = survey_df,
    aes(x = year_date, y = y_num),
    size = 2.2, color = "black", alpha = 0.9
  ) +
  # SST dots (light red) with legend
  geom_point(
    data = sst_df,
    aes(x = date, y = y_num - sst_y_offset, color = "Mean SST (01mo)"),
    size = 0.9, alpha = 0.8
  ) +
  # Chlorophyll dots (light green) with legend
  geom_point(
    data = chl_df,
    aes(x = date, y = y_num - chl_y_offset, color = "Chlorophyll"),
    size = 0.7, alpha = 0.8
  ) +
  # Legend (SST + Chlor) at bottom
  scale_color_manual(
    name   = NULL,
    values = c("Mean SST (01mo)" = "tomato", "Chlorophyll" = "palegreen3"),
    breaks = c("Mean SST (01mo)", "Chlorophyll")
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 3, alpha = 1, shape = 16)
    )
  ) +
  # Axes & theme
  scale_x_date(name = NULL, date_breaks = "6 months", date_labels = "%Y-%m") +
  scale_y_continuous(
    name = NULL,
    breaks = seq_along(site_levels),
    labels = site_levels
  ) +
  ggtitle("Deployments (green), Recoveries (red), Surveys (black), SST (light red), Chlorophyll (light green)") +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.y = element_text(size = 9),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    legend.position = "bottom"
  )

p_timeline
```





## BAR data
### Summary
```{r barDeploymentSummaryData, include=FALSE}
nBars <- nrow(barData)
nLoc1 <-length(unique(barData$loc1))
listLoc1 <-unique(barData$loc1)
nLoc2 <-length(unique(barData$loc2))
listLoc2 <-unique(barData$loc2)
nLoc3 <-length(unique(barData$loc3))
minDeployment <- min(barData$dateDeployment)
maxDeployment <- max(barData$dateDeployment)
minRecovery <- min(barData$dateRecovery)
maxRecovery <- max(barData$dateRecovery)
minDuration <- min(barData$daysDeployed)
maxDuration <- max(barData$daysDeployed)
meanDuration <- mean(barData$daysDeployed)
```

There are a total of `r nBars` bars included in this study. Sites are divided at three levels across 2 basins. The highest level (loc1) includes `r nLoc1` large regions including:  
<small>`r listLoc1`</small>  
  
Within these larger regions are `r nLoc2` sublevels (loc2) that are generally inclusive of an island including:  
<small>`r listLoc2`</small>  
  
Most islands or loc2 level includes multiple sites (loc3) within it, totaling `r nLoc3` loc3 levels across both basins
  
Deployment dates ranged from `r minDeployment` to `r maxDeployment` and recovery dates ranged from `r minRecovery` to `r maxRecovery`. The deployment duration ranged from `r minDuration` to `r maxDuration` days and was on `r meanDuration` days.

### Calculation of stats for bar alteration by loc2
```{r barStatCalculations_loc2, echo=FALSE}
barStatsLoc2 <- barData %>%
  filter(!is.na(grazing_mm3cm2y)) %>%
  group_by(basin, loc1, loc2, loc1.2) %>%
  summarise(
    # duration
    maxDays = max(daysDeployed, na.rm = TRUE),
    minDays = min(daysDeployed, na.rm = TRUE),
    n       = dplyr::n(),

    # depth
    maxDepth  = max(depth, na.rm = TRUE),
    minDepth  = min(depth, na.rm = TRUE),
    meanDepth = mean(depth, na.rm = TRUE),

    # deltaMass
    meanDeltaMass = mean(deltaMass_mgcm2y, na.rm = TRUE),
    sdDeltaMass   = sd(deltaMass_mgcm2y,   na.rm = TRUE),
    seDeltaMass   = sd(deltaMass_mgcm2y,   na.rm = TRUE) / sqrt(n),

    # deltaVolume
    meanDeltaVolume = mean(deltaVolume_mm3cm2y, na.rm = TRUE),
    sdDeltaVolume   = sd(deltaVolume_mm3cm2y,   na.rm = TRUE),
    seDeltaVolume   = sd(deltaVolume_mm3cm2y,   na.rm = TRUE) / sqrt(n),

    # deltaDensity
    meanDeltaDensity = mean(deltaDensity_mgcm3cm2y, na.rm = TRUE),
    sdDeltaDensity   = sd(deltaDensity_mgcm3cm2y,   na.rm = TRUE),
    seDeltaDensity   = sd(deltaDensity_mgcm3cm2y,   na.rm = TRUE) / sqrt(n),

    # macroboring
    meanMacroboring = mean(macroboring_mm3cm2y, na.rm = TRUE),
    sdMacroboring   = sd(macroboring_mm3cm2y,   na.rm = TRUE),
    seMacroboring   = sd(macroboring_mm3cm2y,   na.rm = TRUE) / sqrt(n),

    # grazing
    meanGrazing = mean(grazing_mm3cm2y, na.rm = TRUE),
    sdGrazing   = sd(grazing_mm3cm2y,   na.rm = TRUE),
    seGrazing   = sd(grazing_mm3cm2y,   na.rm = TRUE) / sqrt(n),

    # accretion
    meanAccretion = mean(accretion_mm3cm2y, na.rm = TRUE),
    sdAccretion   = sd(accretion_mm3cm2y,   na.rm = TRUE),
    seAccretion   = sd(accretion_mm3cm2y,   na.rm = TRUE) / sqrt(n),
    .groups = "drop"
  )

kbl(barStatsLoc2, align = "l") %>%
  kable_classic(full_width = FALSE, html_font = "Cambria") %>%
  add_header_above(c(
    "location"     = 4,
    "duration"     = 3,  # maxDays, minDays, n
    "depth"        = 3,
    "deltaMass"    = 3,
    "deltaVolume"  = 3,
    "deltaDensity" = 3,
    "macroboring"  = 3,
    "grazing"      = 3,
    "accretion"    = 3
  )) %>%
  scroll_box(width = "1000px", height = "500px")
```
### Calculation of stats for bar alteration by loc3
```{r barStatCalculations_loc3, echo=FALSE}
barStatsLoc3 <- barData %>%
  filter(!is.na(grazing_mm3cm2y)) %>%
  #group_by(basin, loc1, loc2, loc1.2, loc3, latitude, longitude) %>% ##Note: grouping with lat/long is problematic since some Loc3 sites are marginally different lat/long
  group_by(basin, loc1, loc2, loc1.2, loc3) %>%
  summarise(
    latitude  = mean(latitude,  na.rm = TRUE),#Added based on the above note
    longitude = mean(longitude, na.rm = TRUE),#Added based on the above note 
    n = dplyr::n(),
    maxDepth = max(depth, na.rm = TRUE),
    minDepth = min(depth, na.rm = TRUE),
    meanDepth = mean(depth, na.rm = TRUE),
    maxDate = max(dateRecovery, na.rm = TRUE),
    minDate = min(dateDeployment, na.rm = TRUE),
    maxDays = max(daysDeployed, na.rm = TRUE),
    minDays = min(daysDeployed, na.rm = TRUE),

    meanDeltaMass   = mean(deltaMass_mgcm2y, na.rm = TRUE),
    sdDeltaMass     = sd(deltaMass_mgcm2y, na.rm = TRUE),
    seDeltaMass     = sd(deltaMass_mgcm2y, na.rm = TRUE) / sqrt(n),

    meanDeltaVolume = mean(deltaVolume_mm3cm2y, na.rm = TRUE),
    sdDeltaVolume   = sd(deltaVolume_mm3cm2y, na.rm = TRUE),
    seDeltaVolume   = sd(deltaVolume_mm3cm2y, na.rm = TRUE) / sqrt(n),

    meanDeltaDensity = mean(deltaDensity_mgcm3cm2y, na.rm = TRUE),
    sdDeltaDensity   = sd(deltaDensity_mgcm3cm2y, na.rm = TRUE),
    seDeltaDensity   = sd(deltaDensity_mgcm3cm2y, na.rm = TRUE) / sqrt(n),

    meanMacroboring = mean(macroboring_mm3cm2y, na.rm = TRUE),
    sdMacroboring   = sd(macroboring_mm3cm2y, na.rm = TRUE),
    seMacroboring   = sd(macroboring_mm3cm2y, na.rm = TRUE) / sqrt(n),

    meanGrazing = mean(grazing_mm3cm2y, na.rm = TRUE),
    sdGrazing   = sd(grazing_mm3cm2y, na.rm = TRUE),
    seGrazing   = sd(grazing_mm3cm2y, na.rm = TRUE) / sqrt(n),

    meanAccretion = mean(accretion_mm3cm2y, na.rm = TRUE),
    sdAccretion   = sd(accretion_mm3cm2y, na.rm = TRUE),
    seAccretion   = sd(accretion_mm3cm2y, na.rm = TRUE) / sqrt(n),
    .groups = "drop"
  )

# Nicely formatted output
kbl(barStatsLoc3, align = "l") %>%
  kable_classic(full_width = FALSE, html_font = "Cambria") %>%
  add_header_above(c(
    "location"     = 5,
    "gps"          = 2,
    "sample size"  = 1,
    "depth"        = 3,
    "deployment"   = 2,
    "duration"     = 2,
    "deltaMass"    = 3,
    "deltaVolume"  = 3,
    "deltaDensity" = 3,
    "macroboring"  = 3,
    "grazing"      = 3,
    "accretion"    = 3
  )) %>%
  scroll_box(width = "1000px", height = "500px")
```



## Parrot fish community
### Summary
```{r, include=FALSE}
nParrotSurveys <- nrow(parrotCommunityData)
nParrotLoc1 <-length(unique(parrotCommunityData$loc1))
listParrotLoc1 <-unique(parrotCommunityData$loc1)
nParrotLoc2 <-length(unique(parrotCommunityData$loc2))
listParrotLoc2 <-unique(parrotCommunityData$loc2)
nParrotLoc3 <-length(unique(parrotCommunityData$loc3))
```

There are a total of `r nParrotSurveys` parrot surveys included in this study. Sites are divided at three levels across 2 basins. The highest level (loc1) includes `r nParrotLoc1` large regions including:  
<small>`r listParrotLoc1`</small>  

### Unify parrot tables and calculate stats at loc3 level
```{r unifyParrotTablesLoc3, echo=FALSE}
# ---------- Clean & standardize ----------
parrotCommunityData_clean <- parrotCommunityData %>%
  mutate(
    across(c(basin, loc1, loc2, loc3), ~ .x |> as.character() |> str_squish()),
    `loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)) |> str_squish()
  )

parrotFXNData_clean <- parrotFXNData %>%
  mutate(
    across(c(basin, loc1, loc2, loc3), ~ .x |> as.character() |> str_squish()),
    `loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)) |> str_squish(),
    fxnGroup = case_when(
      str_to_lower(fxnGroup) %in% c("scraper", "scrapers") ~ "scraper",
      str_to_lower(fxnGroup) %in% c("excavator", "excavators") ~ "excavator",
      TRUE ~ str_to_lower(fxnGroup)
    )
  )

# ---------- Community summary (means/SDs + N) ----------
comm_summary <- parrotCommunityData_clean %>%
  group_by(basin, loc1, loc2, `loc1.2`, loc3) %>%
  summarise(
    comm_density_mean = mean(density_ind_ha, na.rm = TRUE),
    comm_density_sd   = sd(density_ind_ha,   na.rm = TRUE),
    comm_density_n    = sum(!is.na(density_ind_ha)),
    comm_biomass_mean = mean(biomass_kg_ha,  na.rm = TRUE),
    comm_biomass_sd   = sd(biomass_kg_ha,    na.rm = TRUE),
    comm_biomass_n    = sum(!is.na(biomass_kg_ha)),
    .groups = "drop"
  )

# ---------- FXN summary (means/SDs + N) and widen ----------
fxn_summary <- parrotFXNData_clean %>%
  filter(fxnGroup %in% c("scraper", "excavator")) %>%
  group_by(basin, loc1, loc2, `loc1.2`, loc3, fxnGroup) %>%
  summarise(
    fxn_density_mean = mean(density_ind_ha, na.rm = TRUE),
    fxn_density_sd   = sd(density_ind_ha,   na.rm = TRUE),
    fxn_density_n    = sum(!is.na(density_ind_ha)),
    fxn_biomass_mean = mean(biomass_kg_ha,  na.rm = TRUE),
    fxn_biomass_sd   = sd(biomass_kg_ha,    na.rm = TRUE),
    fxn_biomass_n    = sum(!is.na(biomass_kg_ha)),
    .groups = "drop"
  ) %>%
  pivot_wider(
    names_from  = fxnGroup,
    values_from = c(fxn_density_mean, fxn_density_sd, fxn_density_n,
                    fxn_biomass_mean, fxn_biomass_sd, fxn_biomass_n),
    names_sep   = "_"
  )

# ---------- Merge & order columns ----------
parrot_loc3_summary <- comm_summary %>%
  full_join(fxn_summary, by = c("basin","loc1","loc2","loc1.2","loc3")) %>%
  arrange(basin, loc1, loc2, `loc1.2`, loc3) %>%
  select(
    basin, loc1, loc2, `loc1.2`, loc3,
    # Community
    comm_density_mean, comm_density_sd, comm_density_n,
    comm_biomass_mean, comm_biomass_sd, comm_biomass_n,
    # Excavators
    fxn_density_mean_excavator, fxn_density_sd_excavator, fxn_density_n_excavator,
    fxn_biomass_mean_excavator, fxn_biomass_sd_excavator, fxn_biomass_n_excavator,
    # Scrapers
    fxn_density_mean_scraper, fxn_density_sd_scraper, fxn_density_n_scraper,
    fxn_biomass_mean_scraper, fxn_biomass_sd_scraper, fxn_biomass_n_scraper
  )

# ---------- Consistency checks ----------
tol <- 1e-6
check_parrots <- parrot_loc3_summary %>%
  mutate(
    fxn_biomass_sum = fxn_biomass_mean_scraper + fxn_biomass_mean_excavator,
    fxn_density_sum = fxn_density_mean_scraper + fxn_density_mean_excavator,
    biomass_close = abs(comm_biomass_mean - fxn_biomass_sum) < tol,
    density_close = abs(comm_density_mean - fxn_density_sum) < tol,
    both_close = biomass_close & density_close
  )

percent_biomass <- mean(check_parrots$biomass_close, na.rm = TRUE) * 100
percent_density <- mean(check_parrots$density_close, na.rm = TRUE) * 100
percent_both    <- mean(check_parrots$both_close,    na.rm = TRUE) * 100

cat("Percent of sites where biomass matches: ", round(percent_biomass, 1), "%\n")
cat("Percent of sites where density matches: ", round(percent_density, 1), "%\n")
cat("Percent of sites where BOTH match:     ", round(percent_both, 1), "%\n")

# ---------- Neat kable (Community/Excavators/Scrapers ABOVE Density/Biomass) ----------
display_tbl <- parrot_loc3_summary %>%
  mutate(
    across(matches("(mean|sd)$"), ~ round(., 1)),
    across(ends_with("_n"), ~ as.integer(.))
  )

align_vec <- c(rep("l", 5), rep("r", 18))

kbl(
  display_tbl,
  booktabs = TRUE,
  align = align_vec,
  col.names = c(
    "Basin","Loc1","Loc2","Loc1.2","Loc3",
    # Community
    "Mean","SD","N", "Mean","SD","N",
    # Excavators
    "Mean","SD","N", "Mean","SD","N",
    # Scrapers
    "Mean","SD","N", "Mean","SD","N"
  ),
  caption = "Parrot community & functional-group summary at loc3 (Mean, SD, N)."
) %>%
  # Add the INNER row first (Density/Biomass), so the next call sits ABOVE it:
  add_header_above(
    c(" " = 5,
      "Density" = 3, "Biomass" = 3,
      "Density" = 3, "Biomass" = 3,
      "Density" = 3, "Biomass" = 3),
    bold = FALSE
  ) %>%
  # Add the OUTER row second (Community / Excavators / Scrapers) so it appears ON TOP:
  add_header_above(c(" " = 5, "Community" = 6, "Excavators" = 6, "Scrapers" = 6)) %>%
  kable_styling(
    full_width = FALSE,
    position = "left",
    font_size = 11,
    bootstrap_options = c("striped","hover","condensed","responsive")
  ) %>%
  scroll_box(width = "100%", height = "520px")
```

### Unify parrot tables and calculate stats at loc2 level
```{r unifyParrotTablesLoc2, echo=FALSE}
# ---------- Clean & standardize ----------
parrotCommunityData_clean <- parrotCommunityData %>%
  mutate(
    across(c(basin, loc1, loc2, loc3), ~ .x |> as.character() |> str_squish()),
    `loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)) |> str_squish()
  )

parrotFXNData_clean <- parrotFXNData %>%
  mutate(
    across(c(basin, loc1, loc2, loc3), ~ .x |> as.character() |> str_squish()),
    `loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)) |> str_squish(),
    fxnGroup = case_when(
      str_to_lower(fxnGroup) %in% c("scraper", "scrapers") ~ "scraper",
      str_to_lower(fxnGroup) %in% c("excavator", "excavators") ~ "excavator",
      TRUE ~ str_to_lower(fxnGroup)
    )
  )

# ---------- Community summary (means/SDs + N) at loc2 ----------
comm_summary <- parrotCommunityData_clean %>%
  group_by(basin, loc1, loc2, `loc1.2`) %>%
  summarise(
    comm_density_mean = mean(density_ind_ha, na.rm = TRUE),
    comm_density_sd   = sd(density_ind_ha,   na.rm = TRUE),
    comm_density_n    = sum(!is.na(density_ind_ha)),
    comm_biomass_mean = mean(biomass_kg_ha,  na.rm = TRUE),
    comm_biomass_sd   = sd(biomass_kg_ha,    na.rm = TRUE),
    comm_biomass_n    = sum(!is.na(biomass_kg_ha)),
    .groups = "drop"
  )

# ---------- FXN summary (means/SDs + N) and widen at loc2 ----------
fxn_summary <- parrotFXNData_clean %>%
  filter(fxnGroup %in% c("scraper", "excavator")) %>%
  group_by(basin, loc1, loc2, `loc1.2`, fxnGroup) %>%
  summarise(
    fxn_density_mean = mean(density_ind_ha, na.rm = TRUE),
    fxn_density_sd   = sd(density_ind_ha,   na.rm = TRUE),
    fxn_density_n    = sum(!is.na(density_ind_ha)),
    fxn_biomass_mean = mean(biomass_kg_ha,  na.rm = TRUE),
    fxn_biomass_sd   = sd(biomass_kg_ha,    na.rm = TRUE),
    fxn_biomass_n    = sum(!is.na(biomass_kg_ha)),
    .groups = "drop"
  ) %>%
  pivot_wider(
    names_from  = fxnGroup,
    values_from = c(fxn_density_mean, fxn_density_sd, fxn_density_n,
                    fxn_biomass_mean, fxn_biomass_sd, fxn_biomass_n),
    names_sep   = "_"
  )

# ---------- Merge & order columns ----------
parrot_loc2_summary <- comm_summary %>%
  full_join(fxn_summary, by = c("basin","loc1","loc2","loc1.2")) %>%
  arrange(basin, loc1, loc2, `loc1.2`) %>%
  select(
    basin, loc1, loc2, `loc1.2`,
    # Community
    comm_density_mean, comm_density_sd, comm_density_n,
    comm_biomass_mean, comm_biomass_sd, comm_biomass_n,
    # Excavators
    fxn_density_mean_excavator, fxn_density_sd_excavator, fxn_density_n_excavator,
    fxn_biomass_mean_excavator, fxn_biomass_sd_excavator, fxn_biomass_n_excavator,
    # Scrapers
    fxn_density_mean_scraper, fxn_density_sd_scraper, fxn_density_n_scraper,
    fxn_biomass_mean_scraper, fxn_biomass_sd_scraper, fxn_biomass_n_scraper
  )

# ---------- Consistency checks ----------
tol <- 1e-6
check_parrots <- parrot_loc2_summary %>%
  mutate(
    fxn_biomass_sum = fxn_biomass_mean_scraper + fxn_biomass_mean_excavator,
    fxn_density_sum = fxn_density_mean_scraper + fxn_density_mean_excavator,
    biomass_close = abs(comm_biomass_mean - fxn_biomass_sum) < tol,
    density_close = abs(comm_density_mean - fxn_density_sum) < tol,
    both_close = biomass_close & density_close
  )

percent_biomass <- mean(check_parrots$biomass_close, na.rm = TRUE) * 100
percent_density <- mean(check_parrots$density_close, na.rm = TRUE) * 100
percent_both    <- mean(check_parrots$both_close,    na.rm = TRUE) * 100

cat("Percent of loc2 groups where biomass matches: ", round(percent_biomass, 1), "%\n")
cat("Percent of loc2 groups where density matches: ", round(percent_density, 1), "%\n")
cat("Percent of loc2 groups where BOTH match:     ", round(percent_both, 1), "%\n")

# ---------- Neat kable (Community/Excavators/Scrapers ABOVE Density/Biomass) ----------
display_tbl <- parrot_loc2_summary %>%
  mutate(
    across(matches("(mean|sd)$"), ~ round(., 1)),
    across(ends_with("_n"), ~ as.integer(.))
  )

align_vec <- c(rep("l", 4), rep("r", 18))

kbl(
  display_tbl,
  booktabs = TRUE,
  align = align_vec,
  col.names = c(
    "Basin","Loc1","Loc2","Loc1.2",
    # Community
    "Mean","SD","N", "Mean","SD","N",
    # Excavators
    "Mean","SD","N", "Mean","SD","N",
    # Scrapers
    "Mean","SD","N", "Mean","SD","N"
  ),
  caption = "Parrot community & functional-group summary at loc2 (Mean, SD, N)."
) %>%
  # Inner row (Density/Biomass), so the next call sits above it:
  add_header_above(
    c(" " = 4,
      "Density" = 3, "Biomass" = 3,
      "Density" = 3, "Biomass" = 3,
      "Density" = 3, "Biomass" = 3),
    bold = FALSE
  ) %>%
  # Outer row (Community / Excavators / Scrapers) on top:
  add_header_above(c(" " = 4, "Community" = 6, "Excavators" = 6, "Scrapers" = 6)) %>%
  kable_styling(
    full_width = FALSE,
    position = "left",
    font_size = 11,
    bootstrap_options = c("striped","hover","condensed","responsive")
  ) %>%
  scroll_box(width = "100%", height = "520px")
```

## Environmental data
Table of summary statistics for loc2 sites
```{r, echo=FALSE}
siteEnvironmentalStats <- environmentalData %>%
  filter(mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo != "")%>%
  filter(mean_PAR_NASA_VIIRS_monthly_01mo != "")%>% 
  group_by(basin, loc1, loc2, loc1.2, loc3, lat, lon) %>%
  summarise(maxDate = max(date), minDate = min(date), n = n(), 
            maxTemperature = max(mean_Sea_Surface_Temperature_CRW_daily_01mo), minTemperature = min(mean_Sea_Surface_Temperature_CRW_daily_01mo), meanTemperature = mean(mean_Sea_Surface_Temperature_CRW_daily_01mo),
            maxSalinity = max(mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo), minSalinity = min(mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo), meanSalinity = mean(mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo),
            maxPAR = max(mean_PAR_NASA_VIIRS_monthly_01mo), minPAR = min(mean_PAR_NASA_VIIRS_monthly_01mo), meanPAR = mean(mean_PAR_NASA_VIIRS_monthly_01mo))
kbl(siteEnvironmentalStats) %>%
  kable_classic(full_width = F, html_font = "Cambria") %>%
#  add_header_above(c("location" = 3, "deployment" = 3, "depth" = 3, "deltaMass" = 3, "deltaVolume" = 3, "deltaDensity" = 3,"macroboring" = 3, "grazing" = 3, "accretion" = 3))%>%
  scroll_box(height = "500px")
```

## Volume vs. Mass
Plot of deltaVolume_mm3cm2y vs. deltaMass_mgcm2y:
```{r, echo=FALSE}
#linear model
  lm_model_volVsMass <- lm(deltaVolume_mm3cm2y ~ deltaMass_mgcm2y, data = barData)
#model summary
  model_summary <- summary(lm_model_volVsMass)
  intercept <- coef(model_summary)[1, 1]
  slope <- coef(model_summary)[2, 1]
  p_value <- coef(model_summary)[2, 4]
  r_squared <- model_summary$r.squared
  lab <- sprintf("y = %.2f + %.3fx\nR² = %.2f   p = %.2g",
    coef(model_summary)[1,1], coef(model_summary)[2,1], model_summary$r.squared, coef(model_summary)[2,4])
#create the plot
ggplot(barData,
       aes(x = deltaMass_mgcm2y,
           y = deltaVolume_mm3cm2y,
           color = factor(loc1.2))) +
  geom_point(size = 2, alpha = 0.8) +
  geom_smooth(aes(group = 1), method = "lm", se = TRUE, color = "black") +
  scale_color_manual(values = loc_colors) +
  coord_cartesian(ylim = c(-150, 50)) +         # safer than scale_y_continuous(limits=...)
  labs(
    x = expression(Delta~mass~(mg~cm^-2~y^-1)),
    y = expression(Delta~volume~(mm^3~cm^-2~y^-1))
  ) +
  geom_text(x = 100, y = -100, label = paste(lab), size = 4, color = "black")+
  theme_bw(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    panel.border = element_rect(fill = NA, color = "black"),
    axis.text = element_text(color = "black", size = 10),
    axis.title = element_text(color = "black", size = 11),
    legend.position = "none"
  )
```


# Spatial analysis of parrotfish data
## General prevalence data
Combine bar stats and parrot community stats tables
```{r, echo=FALSE}
barParrotStatsLoc2 <- inner_join(barStatsLoc2, parrot_loc2_summary, by = c("basin","loc1","loc2","loc1.2"))
barParrotStatsLoc3 <- inner_join(barStatsLoc3, parrot_loc3_summary, by = c("basin","loc1","loc2","loc1.2","loc3"))
```

### Mean parrot biomass_kg_ha vs parrot density_ind_ha by point
```{r, echo=FALSE}
parrotBiomassDensityPlot <-
  plot_scatter_lm_full_atl_pac(
    parrotCommunityData,
    x = "density_ind_ha",
    y = "biomass_kg_ha", 
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = expression(Parrot~biomass~(kg~ha^-1))
  )
parrotBiomassDensityPlot
```

### Parrot biomass vs. density by loc2 and loc3
```{r, echo=FALSE}
# ---------- Community ----------
parrotBiomassDensityCommLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,      
    x = "comm_density_mean",
    y = "comm_biomass_mean",
    sd_x = "comm_density_sd",
    sd_y = "comm_biomass_sd",
    xlab = expression(Community~density~(ind~ha^-1)),
    ylab = expression(Community~biomass~(kg~ha^-1))
  )

parrotBiomassDensityCommLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,      
    x = "comm_density_mean",
    y = "comm_biomass_mean",
    sd_x = "comm_density_sd",
    sd_y = "comm_biomass_sd",
    xlab = expression(Community~density~(ind~ha^-1)),
    ylab = expression(Community~biomass~(kg~ha^-1))
  )

parrotBiomassDensityCommPlot <-
  (parrotBiomassDensityCommLoc2Plot | parrotBiomassDensityCommLoc3Plot) +
  plot_annotation(
    title = "Community",
    theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
    )
  )
# ---------- Scraper ----------
parrotBiomassDensityScraperLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,      
    x = "fxn_density_mean_scraper",
    y = "fxn_biomass_mean_scraper",
    sd_x = "fxn_density_sd_scraper",
    sd_y = "fxn_biomass_sd_scraper",
    xlab = expression(Scraper~density~(ind~ha^-1)),
    ylab = expression(Scraper~biomass~(kg~ha^-1))
  )

parrotBiomassDensityScraperLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,      
    x = "fxn_density_mean_scraper",
    y = "fxn_biomass_mean_scraper",
    sd_x = "fxn_density_sd_scraper",
    sd_y = "fxn_biomass_sd_scraper",
    xlab = expression(Scraper~density~(ind~ha^-1)),
    ylab = expression(Scraper~biomass~(kg~ha^-1))
  )
parrotBiomassDensityScraperPlot <-
  (parrotBiomassDensityScraperLoc2Plot | parrotBiomassDensityScraperLoc3Plot) +
  plot_annotation(
    title = "Scraper",
    theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
    )
  )

# ---------- Excavator ----------
parrotBiomassDensityExcavatorLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,      
    x = "fxn_density_mean_excavator",
    y = "fxn_biomass_mean_excavator",
    sd_x = "fxn_density_sd_excavator",
    sd_y = "fxn_biomass_sd_excavator",
    xlab = expression(Excavator~density~(ind~ha^-1)),
    ylab = expression(Excavator~biomass~(kg~ha^-1))
  )

parrotBiomassDensityExcavatorLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,      
    x = "fxn_density_mean_excavator",
    y = "fxn_biomass_mean_excavator",
    sd_x = "fxn_density_sd_excavator",
    sd_y = "fxn_biomass_sd_excavator",
    xlab = expression(Excavator~density~(ind~ha^-1)),
    ylab = expression(Excavator~biomass~(kg~ha^-1))
  )
parrotBiomassDensityExcavatorPlot <-
  (parrotBiomassDensityExcavatorLoc2Plot | parrotBiomassDensityExcavatorLoc3Plot) +
  plot_annotation(
    title = "Excavator",
    theme = theme(
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5)
    )
  )

# --- Display all three ---

parrotBiomassDensityCommPlot
parrotBiomassDensityScraperPlot
parrotBiomassDensityExcavatorPlot
```

### Boxplots of biomass and density at loc2 for community, scraper, and excavators
Note that these are based on individual point data
```{r, echo=FALSE}
# ---------- Clean & split ----------
parrotFXNData_clean <- parrotFXNData %>%
  mutate(fxnGroup = tolower(fxnGroup))

fxn_groups <- list(
  all = parrotFXNData_clean,
  scraper = filter(parrotFXNData_clean, fxnGroup == "scraper"),
  excavator = filter(parrotFXNData_clean, fxnGroup == "excavator")
)

# ---------- Loop & plot ----------
plot_panels <- lapply(names(fxn_groups), function(group_name) {
  dat <- fxn_groups[[group_name]]
  
  # Biomass plot
  p_biomass <- ggplot(
    data = subset(dat, !is.na(loc1.2)),
    aes(x = loc1.2, fill = loc1.2, y = biomass_kg_ha)
  ) +
    scale_y_continuous(name = expression(biomass~(kg~ha^-1))) +
    myBoxplotStyle(ylim = c(0, 1100))
  
  # Density plot
  p_density <- ggplot(
    data = subset(dat, !is.na(loc1.2)),
    aes(x = loc1.2, fill = loc1.2, y = density_ind_ha)
  ) +
    scale_y_continuous(name = expression(~density~(ind~ha^-1))) +
    myBoxplotStyle(ylim = c(0, 6000))
  
  # Arrange side-by-side
  combined <- ggarrange(
    p_biomass, p_density,
    ncol = 2,
    common.legend = TRUE,
    legend = "none",
    labels = c("Biomass", "Density")
  )
  
  # Add a title ABOVE the combined figure
  annotate_figure(
    combined,
    top = text_grob(
      paste("Parrotfish", stringr::str_to_title(group_name)),
      face = "bold",
      size = 16
    )
  )
})

# ---------- Access final panels ----------
plot_all        <- plot_panels[[1]]
plot_scraper    <- plot_panels[[2]]
plot_excavator  <- plot_panels[[3]]

# ---------- Display ----------
plot_all
plot_scraper
plot_excavator

```

# Spatial analysis of environmental data
## Types of data
```{r, echo=FALSE}

options(knitr.kable.NA = "")

#-----------------------------
# Helpers
#-----------------------------

# Categorize columns by keyword (includes phytoplankton)
categorize_column <- function(name) {
  n <- tolower(name)
  if (str_detect(n, "temp|sst")) {
    "Temperature"
  } else if (str_detect(n, "salin")) {
    "Salinity"
  } else if (str_detect(n, "phytoplankton")) {
    "Phytoplankton"
  } else if (str_detect(n, "chlor|chl")) {
    "Chlorophyll"
  } else if (str_detect(n, "(^|_)par(_|$)|photosynthetically|irradiance|light")) {
    "PAR / Light"
  } else if (str_detect(n, "(^|_)ph(_|$)")) {
    "pH / Chemistry"
  } else if (str_detect(n, "oxygen|o2")) {
    "Oxygen"
  } else if (str_detect(n, "alk|dic|pco2|co2|ta_|tot_alk|carbonate")) {
    "Carbonate / Alkalinity"
  } else if (str_detect(n, "heat|degree|dhw|crw")) {
    "Thermal Stress"
  } else if (str_detect(n, "date|year|month|day|time")) {
    "Temporal"
  } else if (str_detect(n, "(^|_)lat(_|$)|(^|_)lon(_|$)|coord")) {
    "Geospatial"
  } else if (str_detect(n, "(^|_)mean(_|$)|(^|_)max(_|$)|(^|_)min(_|$)|(^|_)sd(_|$)|(^|_)var(_|$)")) {
    "Statistical Summary"
  } else {
    "Other / Metadata"
  }
}

# Infer sampling frequency from date vector
infer_frequency <- function(dts) {
  dts <- sort(unique(as_date(dts)))
  if (length(dts) < 2) return("insufficient")
  diffs <- as.numeric(diff(dts), units = "days")
  med <- median(diffs, na.rm = TRUE)

  # Allow small tolerances
  if (abs(med - 1) <= 0.25) {
    "daily"
  } else if (abs(med - 7) <= 1.5) {
    "weekly"
  } else if (med >= 27 && med <= 32) {
    "monthly"
  } else if (med >= 80 && med <= 100) {
    "quarterly"
  } else if (med >= 360 && med <= 370) {
    "yearly"
  } else {
    "irregular"
  }
}

#-----------------------------
# Inputs & date handling
#-----------------------------

stopifnot("loc1.2" %in% names(environmentalData))
stopifnot("date"   %in% names(environmentalData))

# Ensure date is Date type (robust parsing)
if (!inherits(environmentalData$date, "Date")) {
  environmentalData <- environmentalData %>%
    mutate(
      date = parse_date_time(
        date,
        orders = c("Y-m-d", "Ymd", "m/d/Y", "d/m/Y", "Y/m/d"),
        tz = "UTC"
      ) %>% as_date()
    )
}

all_sites <- environmentalData %>% distinct(loc1.2) %>% pull(loc1.2)
n_sites  <- length(all_sites)

#-----------------------------
# Per-column profiling
#-----------------------------

col_names <- names(environmentalData)

per_col <- map_dfr(col_names, function(col) {
  # rows where this column has data
  idx_non_na <- !is.na(environmentalData[[col]])

  non_na <- sum(idx_non_na)

  # Sites with at least one value in that column
  covered_sites <- environmentalData %>%
    filter(idx_non_na) %>%
    distinct(loc1.2) %>%
    nrow()

  # date range for that column (where the column has data)
  dates_non_na <- environmentalData$date[idx_non_na]
  start_date <- if (length(dates_non_na) && sum(!is.na(dates_non_na)) > 0) min(dates_non_na, na.rm = TRUE) else NA
  end_date   <- if (length(dates_non_na) && sum(!is.na(dates_non_na)) > 0) max(dates_non_na, na.rm = TRUE) else NA

  # infer frequency only from dates where this column has values
  freq <- if (sum(!is.na(dates_non_na)) >= 2) infer_frequency(dates_non_na) else "insufficient"

  tibble::tibble(
    Column = col,
    Category = categorize_column(col),
    NonNA_Count = non_na,
    Covered_Sites = covered_sites,
    Start = start_date,
    End = end_date,
    Frequency = freq,
    Full_Coverage = covered_sites == n_sites
  )
})

#-----------------------------
# 5 color groups by non-NA count (red -> green)
#-----------------------------

# Quintile breaks with tie handling
if (length(unique(per_col$NonNA_Count)) > 1) {
  brks <- as.numeric(quantile(per_col$NonNA_Count, probs = seq(0, 1, length.out = 6), na.rm = TRUE))
  brks <- unique(brks)
  while (length(brks) < 6) brks <- sort(unique(c(brks, max(brks) + 1)))
  per_col$Value_Group <- cut(per_col$NonNA_Count,
                             breaks = brks,
                             include.lowest = TRUE,
                             labels = paste0("G", 1:5))
  group_ranges <- tibble(
    Group = paste0("G", 1:5),
    Range = paste0(format(brks[-length(brks)], big.mark = ","),
                   "–",
                   format(brks[-1], big.mark = ","))
  )
} else {
  per_col$Value_Group <- factor("G3", levels = paste0("G", 1:5))
  val <- unique(per_col$NonNA_Count)
  group_ranges <- tibble(
    Group = paste0("G", 1:5),
    Range = rep(paste0(val, "–", val), 5)
  )
}

# Red (least) -> Green (most)
grp_colors <- c("#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#1a9850")
names(grp_colors) <- paste0("G", 1:5)

#-----------------------------
# Formatting & render
#-----------------------------

per_col <- per_col %>%
  mutate(
    Column_Display = ifelse(Full_Coverage, paste0("**", Column, "**"), Column),
    Group_Color = grp_colors[as.character(Value_Group)],
    Start_fmt = ifelse(is.na(Start), "", format(Start, "%Y-%m-%d")),
    End_fmt   = ifelse(is.na(End),   "", format(End,   "%Y-%m-%d"))
  )

final_tbl <- per_col %>%
  arrange(Category, desc(NonNA_Count), Column) %>%
  transmute(
    Category,
    Column = Column_Display,
    `# Values (non-NA)` = format(NonNA_Count, big.mark = ","),
    `Sites w/ Data` = paste0(Covered_Sites, "/", n_sites),
    `Start` = Start_fmt,
    `End` = End_fmt,
    `Frequency` = Frequency,
    `Value Group` = cell_spec(
      as.character(Value_Group),
      background = Group_Color,
      color = ifelse(Value_Group %in% c("G4","G5"), "white", "black"),
      bold = Value_Group %in% c("G4","G5"),
      escape = FALSE
    )
  )

main_kable <- kbl(
  final_tbl,
  escape = FALSE,
  caption = "EnvironmentalData — Columns grouped by type. Bold = full coverage across all loc1.2."
) %>%
  kable_paper(full_width = FALSE) %>%
  column_spec(1, width = "16em") %>%
  column_spec(2, width = "22em") %>%
  column_spec(3, width = "10em", monospace = TRUE) %>%
  column_spec(4, width = "8em",  monospace = TRUE) %>%
  column_spec(5, width = "10em", monospace = TRUE) %>%
  column_spec(6, width = "10em", monospace = TRUE) %>%
  column_spec(7, width = "9em")  %>%
  column_spec(8, width = "10em") %>%
  scroll_box(height = "420px")

# Color key
key_tbl <- group_ranges %>%
  mutate(
    `Color` = cell_spec(" ", background = grp_colors[Group], escape = FALSE,
                        extra_css = "padding:0 22px; border:1px solid #ccc;"),
    `Label` = Group
  ) %>%
  select(Label, Range, Color)

key_kable <- kbl(
  key_tbl,
  escape = FALSE,
  col.names = c("Value Group", "Non-NA Count Range", " "),
  caption = "Color Key: G1 (red, least values) → G5 (green, most values)."
) %>%
  kable_paper(full_width = FALSE)

# Render
main_kable
key_kable
```

## Parameters to focus on
Based on the above, we focus on the following:
Temperature: mean_Sea_Surface_Temperature_CRW_daily_01dy
Thermal Stress: Degree_Heating_Weeks_CRW_daily_01wk

```{r, echo=FALSE}
# ---- Selected variables (final agreed set) ----
vars_by_category <- list(
  "Temperature"  = c("mean_Sea_Surface_Temperature_CRW_daily_01mo"),
  "Salinity"     = c("mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo"),
  "Chlorophyll"  = c("mean_Chlorophyll_A_ESA_OC_CCI_v6.0_monthly_01yr"),
  "PAR / Light"  = c("mean_PAR_NASA_VIIRS_monthly_01dy"),
  "Phytoplankton"= c("mean_Median_Phytoplankton_Size_NOAA_PIFSC_monthly_03mo"),
  "Geospatial"   = c("lat", "lon"),
  "Metadata"     = c("basin", "loc1", "loc1.2")
)

vars_focus <- unlist(vars_by_category, use.names = FALSE)

# ---- Data prep ----
stopifnot("date" %in% names(environmentalData), "loc1.2" %in% names(environmentalData))

# Ensure 'date' is properly parsed
if (!inherits(environmentalData$date, "Date")) {
  environmentalData <- environmentalData %>%
    mutate(date = parse_date_time(
      date, orders = c("Y-m-d","Ymd","m/d/Y","d/m/Y","Y/m/d"), tz = "UTC"
    ) %>% as_date())
}

total_sites <- environmentalData %>%
  filter(!is.na(loc1.2)) %>% distinct(loc1.2) %>% nrow()

# Keep only existing variables
present <- intersect(vars_focus, names(environmentalData))

# Helper for category mapping
var_category <- function(v) {
  for (cat in names(vars_by_category)) if (v %in% vars_by_category[[cat]]) return(cat)
  "Other"
}

# ---- Build summary table ----
summary_list <- lapply(present, function(v) {
  idx <- !is.na(environmentalData[[v]])
  n_values <- sum(idx)
  n_sites  <- environmentalData %>% filter(idx) %>% distinct(loc1.2) %>% nrow()

  dts <- environmentalData$date[idx]
  start_dt <- if (any(!is.na(dts))) min(dts, na.rm = TRUE) else as.Date(NA)
  end_dt   <- if (any(!is.na(dts))) max(dts, na.rm = TRUE) else as.Date(NA)

  data.frame(
    Category = var_category(v),
    Parameter = v,
    values_n = n_values,
    sites_covered = n_sites,
    start = ifelse(is.na(start_dt), "", format(start_dt, "%Y-%m-%d")),
    end   = ifelse(is.na(end_dt), "", format(end_dt, "%Y-%m-%d")),
    stringsAsFactors = FALSE
  )
})

summary_tbl <- do.call(rbind, summary_list) %>%
  mutate(
    Category = factor(Category, levels = names(vars_by_category)),
    `Sites (of total)` = paste0(sites_covered, "/", total_sites)
  ) %>%
  arrange(Category, desc(values_n), Parameter) %>%
  select(Category, Parameter,
         `# Values` = values_n,
         `Sites (of total)`,
         `Start` = start, `End` = end)

# ---- Scrollable HTML table ----
kbl(summary_tbl,
    caption = "Focused Environmental Parameters — Coverage Summary"
) %>%
  kable_paper(full_width = FALSE) %>%
  column_spec(1, width = "12em") %>%
  column_spec(2, width = "34em") %>%
  column_spec(3, width = "8em",  monospace = TRUE) %>%
  column_spec(4, width = "11em", monospace = TRUE) %>%
  column_spec(5, width = "10em", monospace = TRUE) %>%
  column_spec(6, width = "10em", monospace = TRUE) %>%
  scroll_box(height = "420px")
```

## Environmental data stats
```{r, echo=FALSE}
# ---- Focused variables (column names from your dataset) ----
var_SST   <- "mean_Sea_Surface_Temperature_CRW_daily_01mo"
var_SSS   <- "mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo"
var_CHL   <- "mean_Chlorophyll_A_ESA_OC_CCI_v6.0_monthly_01yr"
var_PAR   <- "mean_PAR_NASA_VIIRS_monthly_01dy"
var_PHYTO <- "mean_Median_Phytoplankton_Size_NOAA_PIFSC_monthly_03mo"   # single phyto variable

# ---- Ensure needed columns exist (if any are missing, fill with NA so code still runs) ----
needed_cols <- c("basin","loc1","loc2","loc1.2","date", var_SST,var_SSS,var_CHL,var_PAR,var_PHYTO)
missing <- setdiff(needed_cols, names(environmentalData))
if (length(missing) > 0) {
  for (m in missing) environmentalData[[m]] <- NA_real_
}

# ---- Parse date if needed ----
if (!inherits(environmentalData$date, "Date")) {
  suppressWarnings({
    environmentalData$date <- as.Date(environmentalData$date)
  })
}

# ---- Helper: standard error with NA-safe n ----
se_safe <- function(x) {
  x <- x[is.finite(x)]
  n <- length(x)
  if (n <= 1) return(NA_real_)
  stats::sd(x) / sqrt(n)
}

# ---- Build site-level summary (like your barStatsLoc2) ----
siteEnvStats <- environmentalData %>%
  filter(!is.na(loc1.2)) %>%
  group_by(basin, loc1, loc2, loc1.2) %>%
  summarise(
    # date coverage in this site
    startDate = suppressWarnings(min(date, na.rm = TRUE)),
    endDate   = suppressWarnings(max(date, na.rm = TRUE)),

    # SST
    n_SST   = sum(is.finite(.data[[var_SST]])),
    mean_SST = mean(.data[[var_SST]], na.rm = TRUE),
    sd_SST   = sd(.data[[var_SST]], na.rm = TRUE),
    se_SST   = se_safe(.data[[var_SST]]),

    # Salinity
    n_SSS   = sum(is.finite(.data[[var_SSS]])),
    mean_SSS = mean(.data[[var_SSS]], na.rm = TRUE),
    sd_SSS   = sd(.data[[var_SSS]], na.rm = TRUE),
    se_SSS   = se_safe(.data[[var_SSS]]),

    # Chlorophyll-a
    n_CHL   = sum(is.finite(.data[[var_CHL]])),
    mean_CHL = mean(.data[[var_CHL]], na.rm = TRUE),
    sd_CHL   = sd(.data[[var_CHL]], na.rm = TRUE),
    se_CHL   = se_safe(.data[[var_CHL]]),

    # PAR
    n_PAR   = sum(is.finite(.data[[var_PAR]])),
    mean_PAR = mean(.data[[var_PAR]], na.rm = TRUE),
    sd_PAR   = sd(.data[[var_PAR]], na.rm = TRUE),
    se_PAR   = se_safe(.data[[var_PAR]]),

    # Phytoplankton size
    n_PHYTO   = sum(is.finite(.data[[var_PHYTO]])),
    mean_PHYTO = mean(.data[[var_PHYTO]], na.rm = TRUE),
    sd_PHYTO   = sd(.data[[var_PHYTO]], na.rm = TRUE),
    se_PHYTO   = se_safe(.data[[var_PHYTO]]),
    .groups = "drop"
  ) %>%
  # Format dates nicely (avoid Inf/-Inf if site had no dates)
  mutate(
    startDate = ifelse(is.finite(as.numeric(startDate)), format(startDate, "%Y-%m-%d"), ""),
    endDate   = ifelse(is.finite(as.numeric(endDate)),   format(endDate,   "%Y-%m-%d"), "")
  )

# ---- Render table with grouped headers, like your style ----
kbl(siteEnvStats, caption = "Environmental Stats by Site") %>%
  kable_classic(full_width = FALSE, html_font = "Cambria") %>%
  add_header_above(c(
    "location" = 4, "date coverage" = 2,
    "SST" = 4, "Salinity" = 4, "Chlorophyll-a" = 4, "PAR" = 4, "Phytoplankton size" = 4
  )) %>%
  scroll_box(width = "1200px")
```

## Environmental data by site
### Boxplots
```{r, echo=FALSE}
## Sea Surface Temperature
SST_boxplot_by_site <- 
  ggplot(
    data = environmentalData[!is.na(environmentalData$loc1.2),], 
    aes(x = loc1.2, fill = loc1.2, y = mean_Sea_Surface_Temperature_CRW_daily_01mo)
  ) +
  scale_y_continuous(name = expression(SST~(degree*C))) +
  myBoxplotStyle()
SST_boxplot_by_site

## Sea Surface Salinity
SSS_boxplot_by_site <- 
  ggplot(
    data = environmentalData[!is.na(environmentalData$loc1.2),], 
    aes(x = loc1.2, fill = loc1.2, y = mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo)
  ) +
  scale_y_continuous(name = "Salinity (psu)") +
  myBoxplotStyle()
SSS_boxplot_by_site

## Chlorophyll-a
Chl_boxplot_by_site <- 
  ggplot(
    data = environmentalData[!is.na(environmentalData$loc1.2),], 
    aes(x = loc1.2, fill = loc1.2, y = mean_Chlorophyll_A_ESA_OC_CCI_v6.0_monthly_01yr)
  ) +
  scale_y_continuous(name = expression(Chl~a~(mg~m^{-3}))) +
  myBoxplotStyle()
Chl_boxplot_by_site

## PAR (Photosynthetically Active Radiation)
PAR_boxplot_by_site <- 
  ggplot(
    data = environmentalData[!is.na(environmentalData$loc1.2),], 
    aes(x = loc1.2, fill = loc1.2, y = mean_PAR_NASA_VIIRS_monthly_01dy)
  ) +
  scale_y_continuous(name = expression(PAR~(mu*mol~m^{-2}~s^{-1}))) +
  myBoxplotStyle()
PAR_boxplot_by_site

## Median Phytoplankton Size, Note Atlantic data are removed
plot_Phyto_by_site <- ggplot(
  data = subset(environmentalData,
                !is.na(loc1.2) &
                is.finite(mean_Median_Phytoplankton_Size_NOAA_PIFSC_monthly_03mo) &
                basin != "atlantic"),
  aes(x = loc1.2, fill = loc1.2,
      y = mean_Median_Phytoplankton_Size_NOAA_PIFSC_monthly_03mo)
) +
  scale_y_continuous(name = "Median phytoplankton size (µm³)") +
  myBoxplotStyle()
plot_Phyto_by_site

```

### Time series
```{r,  echo=FALSE, fig.width=14, fig.height=8}
# Ensure date parsed
if (!inherits(environmentalData$date, "Date")) {
  environmentalData <- environmentalData %>%
    mutate(date = as.Date(date))
}

# Variables
var_SST   <- "mean_Sea_Surface_Temperature_CRW_daily_01mo"
var_SSS   <- "mean_Sea_Surface_Salinity_MirasSMOS_3Day_03mo"
var_CHL   <- "mean_Chlorophyll_A_ESA_OC_CCI_v6.0_monthly_01yr"
var_PAR   <- "mean_PAR_NASA_VIIRS_monthly_01dy"
var_PHYTO <- "mean_Median_Phytoplankton_Size_NOAA_PIFSC_monthly_03mo"

# Helper: build time-series scatter plot with formatting
make_ts_plot <- function(df, yvar, title, ylab = NULL, alpha = 0.6) {
  d <- df %>%
    filter(!is.na(loc1.2), is.finite(.data[[yvar]]), is.finite(as.numeric(date)))

  p <- ggplot(d, aes(x = date, y = .data[[yvar]], color = loc1.2, group = loc1.2)) +
    geom_point(alpha = alpha, size = 0.7) +
    geom_line(linewidth = 0.3, alpha = 0.5) +
    scale_x_date(name = NULL) +
    scale_y_continuous(name = ylab) +
    facet_wrap(~ loc1.2, scales = "free_y") +
    labs(title = title) +
    theme_minimal(base_size = 12) +
    theme(
      legend.position = "none",
      panel.grid.minor = element_blank(),
      strip.text = element_text(face = "bold"),
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
      plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
    )

  if (exists("loc_colors")) {
    p <- p + scale_color_manual(values = loc_colors)
  }
  p
}

# Build plots
ts_SST   <- make_ts_plot(environmentalData, var_SST,   "Sea Surface Temperature (SST)",    expression(SST~(degree*C)))
ts_SSS   <- make_ts_plot(environmentalData, var_SSS,   "Sea Surface Salinity (SSS)",      "Salinity (psu)")
ts_CHL   <- make_ts_plot(environmentalData, var_CHL,   "Chlorophyll-a Concentration",     expression(Chl~a~(mg~m^{-3})))
ts_PAR   <- make_ts_plot(environmentalData, var_PAR,   "Photosynthetically Active Radiation (PAR)", expression(PAR~(mu*mol~m^{-2}~s^{-1})))
ts_PHYTO <- make_ts_plot(environmentalData, var_PHYTO, "Median Phytoplankton Size",       "Phytoplankton size (µm³)")

# Display them (they'll render one after another)
ts_SST
ts_SSS
ts_CHL
ts_PAR
ts_PHYTO

```


# Spatial analysis of BAR data
## Statistical model of BAR data by loc2 in loc1
```{r nestedModelsPrint, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
dat <- barData

responses <- c(
  "deltaMass_mgcm2y",
  "deltaVolume_mm3cm2y",
  "deltaDensity_mgcm3cm2y",
  "macroboring_mm3cm2y",
  "accretion_mm3cm2y",
  "grazing_mm3cm2y"
)

for (y in responses) {
  dfy <- dat %>%
    dplyr::select(loc1, loc2, !!rlang::sym(y)) %>%
    dplyr::rename(yval = !!rlang::sym(y)) %>%
    dplyr::filter(!is.na(yval)) %>%
    dplyr::mutate(
      loc1 = droplevels(factor(loc1)),
      loc2 = droplevels(factor(loc2))
    )

  # Fit nested ANOVA
  fit <- aov(yval ~ loc1/loc2, data = dfy)
  
  cat("\n\n### ANOVA for ", y, "\n\n", sep = "")
  
  # --- ANOVA TABLE AS KABLE ---
  anova_df <- broom::tidy(fit) %>%
    dplyr::mutate(
      p.value = ifelse(p.value < 0.0001, "<0.0001", round(p.value,4))
    ) %>%
    dplyr::rename(
      term = term,
      df = df,
      sumsq = sumsq,
      meansq = meansq,
      statistic = statistic,
      p.value = p.value
    )
  cat("\n\n#### ANOVA table for ", y, "\n\n", sep = "")  
  print(knitr::kable(
    anova_df, digits = 4
  ))
  
  
  # --- TUKEY POST HOC FOR LOC1 ---
  cat("\n\n#### Tukey post hoc for `loc1` (regions)\n\n")
  
  em1  <- emmeans::emmeans(fit, ~ loc1)
  ph1  <- emmeans::contrast(em1, method = "pairwise", adjust = "tukey")
  
  ph1_df <- as.data.frame(ph1) %>%
    dplyr::mutate(
      p.value = ifelse(p.value < 0.0001, "<0.0001", round(p.value,4))
    ) %>%
    dplyr::select(contrast, estimate, SE, df, t.ratio, p.value)
  
  print(knitr::kable(
    ph1_df, digits = 4,
    caption = paste("Tukey post hoc for loc1 (regions):", y)
  ))
  
  
  # --- TUKEY POST HOC FOR LOC2 WITHIN EACH LOC1 ---
  cat("\n\n#### Tukey post hoc (`loc2` within each `loc1`)\n\n")
  
  em  <- emmeans::emmeans(fit, ~ loc2 | loc1)
  ph  <- emmeans::contrast(em, method = "pairwise", adjust = "tukey")
  
  ph_df <- as.data.frame(ph) %>%
    dplyr::mutate(
      p.value = ifelse(p.value < 0.0001, "<0.0001", round(p.value,4))
    ) %>%
    dplyr::select(loc1, contrast, estimate, SE, df, t.ratio, p.value)
  
  print(knitr::kable(
    ph_df, digits = 4,
    caption = paste("Tukey post hoc for loc2 within each loc1:", y)
  ))
  
  cat("\n\n---\n")
}
```

## Plots of BAR data by loc2
```{r plot_bar_metrics, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

# Named list of variables, pretty y-labels, and y-limits
plot_specs <- list(
  deltaVolume_mm3cm2y  = list(
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1)),
    ylim = c(-150, 10)
  ),
  deltaDensity_mgcm3cm2y = list(
    ylab = expression(Delta~density~(mg~cm^-3~cm^-2~y^-1)),
    ylim = c(-15, 10)
  ),
  macroboring_mm3cm2y = list(
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1)),
    ylim = c(-65, 5)
  ),
  grazing_mm3cm2y = list(
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1)),
    ylim = c(-150, 5)
  ),
  accretion_mm3cm2y = list(
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1)),
    ylim = c(-5, 80)
  )
)

# Loop and produce plots
for (var in names(plot_specs)) {
  
  cat("\n\n### Plot", var, "\n\n")

  p <- ggplot(
    data = subset(barData, !is.na(loc1.2)),
    aes(x = loc1.2, y = .data[[var]], fill = loc1.2)
  ) +
    scale_y_continuous(name = plot_specs[[var]]$ylab) +
    myBoxplotStyle(ylim = plot_specs[[var]]$ylim)

  print(p)
  cat("\n\n---\n")
}
```




# Exploration of grazing as a driver
## BAR data vs. Grazing
### MASS change vs Grazing 
```{r, echo=FALSE}
deltaMassVsGrazingPlot <-
  plot_scatter_lm_full_atl_pac(
    barData,
    x = "grazing_mm3cm2y", y = "deltaMass_mgcm2y",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~mass~(mg~cm^-2~y^-1)),
  )
massVsGrazingLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barStatsLoc2,
    x = "meanGrazing", y = "meanDeltaMass",
    sd_x = "seGrazing", sd_y = "seDeltaMass",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~mass~(mg~cm^-2~y^-1)),
  )
massVsGrazingLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barStatsLoc3,
    x = "meanGrazing", y = "meanDeltaMass",
    sd_x = "seGrazing", sd_y = "seDeltaMass",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~mass~(mg~cm^-2~y^-1)),
  )
deltaMassVsGrazingPlot; massVsGrazingLoc2Plot; massVsGrazingLoc3Plot
```

### VOLUME change vs Grazing
```{r, echo=FALSE}
deltaVolumeVsGrazingPlot <-
  plot_scatter_lm_full_atl_pac(
    barData,
    x = "grazing_mm3cm2y", y = "deltaVolume_mm3cm2y",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1))
  )
volumeVsGrazingLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barStatsLoc2,
    x = "meanGrazing", y = "meanDeltaVolume",
    sd_x = "seGrazing", sd_y = "seDeltaVolume",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1))
  )
volumeVsGrazingLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barStatsLoc3,
    x = "meanGrazing", y = "meanDeltaVolume",
    sd_x = "seGrazing", sd_y = "seDeltaVolume",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~volume~(mm^3~cm^-2~y^-1))
  )
deltaVolumeVsGrazingPlot; volumeVsGrazingLoc2Plot; volumeVsGrazingLoc3Plot
```

### DENSITY change vs Grazing
```{r, echo=FALSE}
deltaDensityVsGrazingPlot <-
  plot_scatter_lm_full_atl_pac(
    barData,
    x = "grazing_mm3cm2y", y = "deltaDensity_mgcm3cm2y",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~density~(mg~cm^-3~y^-1))
  )
deltaDensityVsGrazingLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barStatsLoc2,
    x = "meanGrazing", y = "meanDeltaDensity",
    sd_x = "seGrazing", sd_y = "seDeltaDensity",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~density~(mg~cm^-3~y^-1))
  )
deltaDensityVsGrazingLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barStatsLoc3,
    x = "meanGrazing", y = "meanDeltaDensity",
    sd_x = "seGrazing", sd_y = "seDeltaDensity",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Delta~density~(mg~cm^-3~y^-1))
  )
deltaDensityVsGrazingPlot; deltaDensityVsGrazingLoc2Plot; deltaDensityVsGrazingLoc3Plot
```

### MACROBORING vs Grazing
```{r, echo=FALSE}
macroboringVsGrazingPlot <-
  plot_scatter_lm_full_atl_pac(
    barData,
    x = "grazing_mm3cm2y", y = "macroboring_mm3cm2y",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Macroboring~(mm^3~cm^-2~y^-1))
  )
macroboringVsGrazingLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barStatsLoc2,
    x = "meanGrazing", y = "meanMacroboring",
    sd_x = "seGrazing", sd_y = "seMacroboring",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Macroboring~(mm^3~cm^-2~y^-1))
  )
macroboringVsGrazingLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barStatsLoc3,
    x = "meanGrazing", y = "meanMacroboring",
    sd_x = "seGrazing", sd_y = "seMacroboring",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Macroboring~(mm^3~cm^-2~y^-1))
  )
macroboringVsGrazingPlot; macroboringVsGrazingLoc2Plot; macroboringVsGrazingLoc3Plot
```

### ACCRETION vs Grazing
```{r, echo=FALSE}
accretionVsGrazingPlot <-
  plot_scatter_lm_full_atl_pac(
    barData,
    x = "grazing_mm3cm2y", y = "accretion_mm3cm2y",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Accretion~(mm^3~cm^-2~y^-1))
  )
accretionVsGrazingLoc2Plot <-
  plot_loc2_lm_full_atl_pac(
    barStatsLoc2,
    x = "meanGrazing", y = "meanAccretion",
    sd_x = "seGrazing", sd_y = "seAccretion",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Accretion~(mm^3~cm^-2~y^-1))
  )
accretionVsGrazingLoc3Plot <-
  plot_loc3_lm_full_atl_pac(
    barStatsLoc3,
    x = "meanGrazing", y = "meanAccretion",
    sd_x = "seGrazing", sd_y = "seAccretion",
    xlab = expression(Grazing~(mm^3~cm^-2~y^-1)),
    ylab = expression(Accretion~(mm^3~cm^-2~y^-1))
  )
accretionVsGrazingPlot; accretionVsGrazingLoc2Plot; accretionVsGrazingLoc3Plot
```



# Exploration of parrotfish as a driver
## Parrotfish Loc2 as driver
```{r, createParrotDriverPlotsLoc2, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
# List of response variables
responses <- c(
  "meanDeltaMass",
  "meanDeltaVolume",
  "meanDeltaDensity",
  "meanMacroboring",
  "meanGrazing",
  "meanAccretion"
)

# Helper: make row title
row_title <- function(txt) {
  ggdraw() + draw_label(txt, fontface = "bold", size = 12, x = 0.5, hjust = 0.5)
}

# Loop through each response and make plots
plot_list <- list()

for (resp in responses) {

  # Y-axis label (Δ response)
  ylab_expr <- bquote(Delta~.(gsub("meanDelta", "", resp))~(units))

  # Build plots for community, excavator, scraper — biomass & density
  comm_biomass <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "comm_biomass_mean", y = resp,
    sd_x = "comm_biomass_sd", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  comm_density <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "comm_density_mean", y = resp,
    sd_x = "comm_density_sd", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  excavator_biomass <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "fxn_biomass_mean_excavator", y = resp,
    sd_x = "fxn_biomass_sd_excavator", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  excavator_density <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "fxn_density_mean_excavator", y = resp,
    sd_x = "fxn_density_sd_excavator", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  scraper_biomass <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "fxn_biomass_mean_scraper", y = resp,
    sd_x = "fxn_biomass_sd_scraper", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  scraper_density <- plot_loc2_lm_full_atl_pac(
    barParrotStatsLoc2,
    x = "fxn_density_mean_scraper", y = resp,
    sd_x = "fxn_density_sd_scraper", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  # Build 3x2 grid
  grid <- plot_grid(
    plot_grid(row_title("Community"),
              plot_grid(comm_biomass, comm_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    plot_grid(row_title("Excavator"),
              plot_grid(excavator_biomass, excavator_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    plot_grid(row_title("Scraper"),
              plot_grid(scraper_biomass, scraper_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    ncol = 1
  )

  # Add title to whole grid
  grid_title <- ggdraw() +
    draw_label(paste("Δ Response:", gsub("meanDelta", "Δ ", resp)),
               fontface = "bold", size = 14)

  final_grid <- plot_grid(grid_title, grid, ncol = 1, rel_heights = c(0.1, 1))

  plot_list[[resp]] <- final_grid
}

# Display one (for example, ΔMass)
plot_list["meanDeltaMass"]
plot_list["meanDeltaVolume"]
plot_list["meanDeltaDensity"]
plot_list["meanMacroboring"]
plot_list["meanGrazing"]
plot_list["meanAccretion"]
```

## Parrotfish Loc3 as driver of Loc3 averages
```{r, createParrotDriverPlotsLoc3, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
# List of response variables
responses <- c(
  "meanDeltaMass",
  "meanDeltaVolume",
  "meanDeltaDensity",
  "meanMacroboring",
  "meanGrazing",
  "meanAccretion"
)

# Helper: make row title
row_title <- function(txt) {
  ggdraw() + draw_label(txt, fontface = "bold", size = 12, x = 0.5, hjust = 0.5)
}

# Loop through each response and make plots
plot_list <- list()

for (resp in responses) {

  # Y-axis label (Δ response)
  ylab_expr <- bquote(Delta~.(gsub("meanDelta", "", resp))~(units))

  # Build plots for community, excavator, scraper — biomass & density
  comm_biomass <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "comm_biomass_mean", y = resp,
    sd_x = "comm_biomass_sd", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  comm_density <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "comm_density_mean", y = resp,
    sd_x = "comm_density_sd", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  excavator_biomass <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "fxn_biomass_mean_excavator", y = resp,
    sd_x = "fxn_biomass_sd_excavator", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  excavator_density <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "fxn_density_mean_excavator", y = resp,
    sd_x = "fxn_density_sd_excavator", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  scraper_biomass <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "fxn_biomass_mean_scraper", y = resp,
    sd_x = "fxn_biomass_sd_scraper", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~biomass~(kg~ha^-1)),
    ylab = NULL, group = "basin"
  )

  scraper_density <- plot_loc3_lm_full_atl_pac(
    barParrotStatsLoc3,
    x = "fxn_density_mean_scraper", y = resp,
    sd_x = "fxn_density_sd_scraper", sd_y = paste0("se", sub("mean", "", resp)),
    xlab = expression(Parrot~density~(ind~ha^-1)),
    ylab = NULL, group = "basin"
  )

  # Build 3x2 grid
  grid <- plot_grid(
    plot_grid(row_title("Community"),
              plot_grid(comm_biomass, comm_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    plot_grid(row_title("Excavator"),
              plot_grid(excavator_biomass, excavator_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    plot_grid(row_title("Scraper"),
              plot_grid(scraper_biomass, scraper_density, ncol = 2),
              ncol = 1, rel_heights = c(0.1, 1)),
    ncol = 1
  )

  # Add title to whole grid
  grid_title <- ggdraw() +
    draw_label(paste("Δ Response:", gsub("meanDelta", "Δ ", resp)),
               fontface = "bold", size = 14)

  final_grid <- plot_grid(grid_title, grid, ncol = 1, rel_heights = c(0.1, 1))

  plot_list[[resp]] <- final_grid
}

# Display plots
plot_list["meanDeltaMass"]
plot_list["meanDeltaVolume"]
plot_list["meanDeltaDensity"]
plot_list["meanMacroboring"]
plot_list["meanGrazing"]
plot_list["meanAccretion"]
```

## Parrotfish Loc3 as driver of BAR point data
```{r, createParrotDriverPlotsBars, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
# ====== 1) Join barData (responses) with parrot x-data by loc3 ======
bar_resp_cols <- c(
  "deltaMass_mgcm2y",
  "deltaVolume_mm3cm2y",
  "deltaDensity_mgcm3cm2y",
  "macroboring_mm3cm2y",
  "grazing_mm3cm2y",
  "accretion_mm3cm2y"       # <-- added
)

parrot_x_cols <- c(
  # community
  "comm_biomass_mean", "comm_biomass_sd",
  "comm_density_mean", "comm_density_sd",
  # excavator
  "fxn_biomass_mean_excavator", "fxn_biomass_sd_excavator",
  "fxn_density_mean_excavator", "fxn_density_sd_excavator",
  # scraper
  "fxn_biomass_mean_scraper", "fxn_biomass_sd_scraper",
  "fxn_density_mean_scraper", "fxn_density_sd_scraper"
)

id_cols <- c("loc3","loc1","loc2","loc1.2","basin")

merged_df <- barData %>%
  dplyr::select(dplyr::any_of(c(id_cols, bar_resp_cols))) %>%
  dplyr::left_join(
    barParrotStatsLoc3 %>%
      dplyr::select(dplyr::any_of(c(id_cols, parrot_x_cols))),
    by = "loc3",
    suffix = c("", ".parrot")
  )

# Ensure clean loc1.2
if (!"loc1.2" %in% names(merged_df)) {
  if (any(c("loc1.2.x","loc1.2.y") %in% names(merged_df))) {
    merged_df <- merged_df %>%
      mutate(`loc1.2` = dplyr::coalesce(.data[["loc1.2.x"]], .data[["loc1.2.y"]])) %>%
      select(-dplyr::any_of(c("loc1.2.x","loc1.2.y")))
  } else if (all(c("loc1","loc2") %in% names(merged_df))) {
    merged_df <- merged_df %>%
      mutate(`loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)))
  } else {
    merged_df <- merged_df %>% mutate(`loc1.2` = as.character(loc3))
  }
}

# Normalize basin
if (!"basin" %in% names(merged_df)) merged_df$basin <- NA_character_
merged_df <- merged_df %>% mutate(basin = tolower(as.character(basin)))

# ====== 2) Labels ======
y_labels <- c(
  deltaMass_mgcm2y        = expression(Delta~mass~(mg~cm^{-2}~y^{-1})),
  deltaVolume_mm3cm2y     = expression(Delta~volume~(mm^{3}~cm^{-2}~y^{-1})),
  deltaDensity_mgcm3cm2y  = expression(Delta~density~(mg~cm^{-3}~cm^{-2}~y^{-1})),
  macroboring_mm3cm2y     = expression(Macroboring~(mm^{3}~cm^{-2}~y^{-1})),
  grazing_mm3cm2y         = expression(Grazing~(mm^{3}~cm^{-2}~y^{-1})),
  accretion_mm3cm2y       = expression(Accretion~(mm^{3}~cm^{-2}~y^{-1}))   # <-- added
)

x_labels <- list(
  comm_biomass_mean              = expression(Parrot~biomass~(kg~ha^{-1})),
  comm_density_mean              = expression(Parrot~density~(ind~ha^{-1})),
  fxn_biomass_mean_excavator     = expression(Parrot~biomass~(kg~ha^{-1})),
  fxn_density_mean_excavator     = expression(Parrot~density~(ind~ha^{-1})),
  fxn_biomass_mean_scraper       = expression(Parrot~biomass~(kg~ha^{-1})),
  fxn_density_mean_scraper       = expression(Parrot~density~(ind~ha^{-1}))
)

# ====== 3) Regression helpers ======
interpret_model <- function(R2, p) {
  if (is.na(R2) || is.na(p)) return("insufficient data")
  if (p >= 0.05) return("not significant")
  if (R2 < 0.10) return("weak but significant")
  if (R2 < 0.30) return("moderate")
  "strong"
}

compute_label <- function(df, xvar, yvar) {
  x <- suppressWarnings(as.numeric(df[[xvar]]))
  y <- suppressWarnings(as.numeric(df[[yvar]]))
  n <- sum(stats::complete.cases(x, y))
  ok <- (n > 2) &&
    is.finite(stats::var(x, na.rm = TRUE)) && stats::var(x, na.rm = TRUE) > 0 &&
    is.finite(stats::var(y, na.rm = TRUE)) && stats::var(y, na.rm = TRUE) > 0

  if (ok) {
    fit <- stats::lm(y ~ x)
    s   <- summary(fit)
    R2    <- unname(s$r.squared)
    p     <- unname(s$coefficients[2, 4])
    slope <- unname(stats::coef(fit)[2])
  } else {
    R2 <- NA_real_; p <- NA_real_; slope <- NA_real_
  }

  interp <- interpret_model(R2, p)
  list(
    label = paste0(
      "R²=", ifelse(is.na(R2), "NA", sprintf("%.2f", R2)),
      ", p=", ifelse(is.na(p), "NA", formatC(p, format = "e", digits = 2)),
      ", n=", n,
      ", slope=", ifelse(is.na(slope), "NA", formatC(slope, format = "g", digits = 3)),
      " (", interp, ")"
    ),
    is_sig = (!is.na(p) && p < 0.05)
  )
}

# Plot one panel with All/Atlantic/Pacific fits, with a 3-line legend UNDER the plot
plot_lm_all_atl_pac <- function(df, xvar, yvar, xlab_expr, ylab_expr = NULL, title = NULL) {
  color_scale <- if (exists("loc_colors", inherits = TRUE)) {
    scale_color_manual(values = loc_colors)
  } else {
    scale_color_discrete()
  }

  # compute text blocks (per-line color based on each p-value)
  p_all <- compute_label(df, xvar, yvar)
  p_atl <- compute_label(dplyr::filter(df, basin == "atlantic"), xvar, yvar)
  p_pac <- compute_label(dplyr::filter(df, basin == "pacific"),  xvar, yvar)

  label_df <- tibble::tibble(
    line  = c("All", "Atlantic", "Pacific"),
    text  = c(p_all$label, p_atl$label, p_pac$label),
    color = c(
      if (p_all$is_sig) "#1B9E77" else "grey20",
      if (p_atl$is_sig) "#1B9E77" else "grey20",
      if (p_pac$is_sig) "#1B9E77" else "grey20"
    ),
    y = c(1.00, 0.78, 0.56)
  )

  # base plot: points only
  p <- ggplot(df, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(aes(color = factor(`loc1.2`)), alpha = 0.85) +
    color_scale +
    labs(title = title, x = xlab_expr, y = ylab_expr) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    )

  # add regression lines only if significant
  if (p_all$is_sig) {
    p <- p + geom_smooth(method = "lm", se = TRUE, color = "black")
  }

  if (p_pac$is_sig) {
    p <- p + geom_smooth(
      data = dplyr::filter(df, basin == "pacific"),
      method = "lm", se = TRUE, color = "#377EB8"
    )
  }

  if (p_atl$is_sig) {
    p <- p + geom_smooth(
      data = dplyr::filter(df, basin == "atlantic"),
      method = "lm", se = TRUE, color = "#E41A1C"
    )
  }

  cowplot::plot_grid(
    p,
    cowplot::ggdraw() +
      geom_text(
        data = label_df,
        aes(x = 0, y = y, label = paste0(line, ": ", text), color = I(color)),
        hjust = 0, vjust = 1, size = 3
      ),
    ncol = 1,
    rel_heights = c(1, 0.28)
  )
}

# ====== 4) Row title helper ======
row_title <- function(txt) {
  ggdraw() + draw_label(txt, fontface = "bold", size = 12, x = 0.5, hjust = 0.5)
}

# ====== 5) Build 3×2 grids for each response (barData y; parrot x) ======
responses <- c(
  "deltaMass_mgcm2y",
  "deltaVolume_mm3cm2y",
  "deltaDensity_mgcm3cm2y",
  "macroboring_mm3cm2y",
  "grazing_mm3cm2y",
  "accretion_mm3cm2y"   # <-- added
)

plot_list <- list()

for (resp in responses) {
  ylab_expr <- y_labels[[resp]]

  # Community
  comm_biomass <- plot_lm_all_atl_pac(
    merged_df, "comm_biomass_mean", resp,
    xlab_expr = x_labels$comm_biomass_mean, ylab_expr = NULL
  )
  comm_density <- plot_lm_all_atl_pac(
    merged_df, "comm_density_mean", resp,
    xlab_expr = x_labels$comm_density_mean, ylab_expr = NULL
  )

  # Excavator
  excavator_biomass <- plot_lm_all_atl_pac(
    merged_df, "fxn_biomass_mean_excavator", resp,
    xlab_expr = x_labels$fxn_biomass_mean_excavator, ylab_expr = NULL
  )
  excavator_density <- plot_lm_all_atl_pac(
    merged_df, "fxn_density_mean_excavator", resp,
    xlab_expr = x_labels$fxn_density_mean_excavator, ylab_expr = NULL
  )

  # Scraper
  scraper_biomass <- plot_lm_all_atl_pac(
    merged_df, "fxn_biomass_mean_scraper", resp,
    xlab_expr = x_labels$fxn_biomass_mean_scraper, ylab_expr = NULL
  )
  scraper_density <- plot_lm_all_atl_pac(
    merged_df, "fxn_density_mean_scraper", resp,
    xlab_expr = x_labels$fxn_density_mean_scraper, ylab_expr = NULL
  )

  grid <- plot_grid(
    plot_grid(row_title("Community"),
              plot_grid(comm_biomass + ylab(ylab_expr), comm_density, ncol = 2),
              ncol = 1, rel_heights = c(0.12, 1)),
    plot_grid(row_title("Excavator"),
              plot_grid(excavator_biomass + ylab(ylab_expr), excavator_density, ncol = 2),
              ncol = 1, rel_heights = c(0.12, 1)),
    plot_grid(row_title("Scraper"),
              plot_grid(scraper_biomass + ylab(ylab_expr), scraper_density, ncol = 2),
              ncol = 1, rel_heights = c(0.12, 1)),
    ncol = 1
  )

  grid_title <- ggdraw() +
    draw_label(
      paste("Δ Response:", switch(
        resp,
        deltaMass_mgcm2y       = "Δ Mass",
        deltaVolume_mm3cm2y    = "Δ Volume",
        deltaDensity_mgcm3cm2y = "Δ Density",
        macroboring_mm3cm2y    = "Macroboring",
        grazing_mm3cm2y        = "Grazing",
        accretion_mm3cm2y      = "Accretion",
        resp
      )),
      fontface = "bold", size = 14
    )

  final_grid <- plot_grid(grid_title, grid, ncol = 1, rel_heights = c(0.12, 1))
  plot_list[[resp]] <- final_grid
}

# ====== 6) Display ======
print(plot_list[["deltaMass_mgcm2y"]])
print(plot_list[["deltaVolume_mm3cm2y"]])
print(plot_list[["deltaDensity_mgcm3cm2y"]])
print(plot_list[["macroboring_mm3cm2y"]])
print(plot_list[["grazing_mm3cm2y"]])
print(plot_list[["accretion_mm3cm2y"]]) 
```



# Exploration of environmental data as a driver
```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE, fig.width=18, fig.height=14}
# Cleaner to avoid lm() errors from NaN/Inf ---
clean_numeric <- function(df) {
  df %>%
    mutate(across(where(is.numeric), \(v) {
      v[is.nan(v) | is.infinite(v)] <- NA_real_
      v
    }))
}
barStatsLoc2 <- clean_numeric(barStatsLoc2)
siteEnvStats <- clean_numeric(siteEnvStats)

# --- Build joined table with ALL needed response + env columns ---
siteStatsEnv <- barStatsLoc2 %>%
  select(
    basin, loc1, loc2, loc1.2,
    meanDeltaMass,   seDeltaMass,
    meanDeltaVolume, seDeltaVolume,
    meanDeltaDensity,seDeltaDensity,
    meanMacroboring, seMacroboring,
    meanGrazing,     seGrazing,
    meanAccretion,   seAccretion
  ) %>%
  inner_join(
    siteEnvStats %>%
      select(
        basin, loc1, loc2, loc1.2,
        mean_SST,   se_SST,
        mean_SSS,   se_SSS,
        mean_CHL,   se_CHL,
        mean_PAR,   se_PAR,
        mean_PHYTO, se_PHYTO
      ),
    by = c("basin","loc1","loc2","loc1.2")
  )
# --- Helper -----------------------------------------------------------------
plot_site_lm_safe <- function(data, x, y, sd_x, sd_y, xlab, ylab, ...) {
  needed <- c(x, y, sd_x, sd_y)
  miss <- setdiff(needed, names(data))
  if (length(miss) > 0) stop("Missing columns: ", paste(miss, collapse = ", "))

  df <- data %>% filter(is.finite(.data[[x]]), is.finite(.data[[y]]))
  if (nrow(df) >= 2) {
    plot_loc2_lm_full_atl_pac(
      df, x = x, y = y, sd_x = sd_x, sd_y = sd_y,
      xlab = xlab, ylab = ylab, ...
    )
  } else {
    ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
      geom_point(alpha = 0.85) +
      geom_errorbar(aes(ymin = .data[[y]] - .data[[sd_y]],
                        ymax = .data[[y]] + .data[[sd_y]]),
                    width = 0, alpha = 0.4, na.rm = TRUE) +
      labs(x = xlab, y = ylab, title = "Insufficient data for linear model") +
      theme_minimal(base_size = 12)
  }
}

# Environmental drivers
env_specs <- list(
  list(x = "mean_SST",   sd_x = "se_SST",   xlab = expression(SST~(degree*C))),
  list(x = "mean_SSS",   sd_x = "se_SSS",   xlab = "Salinity (psu)"),
  list(x = "mean_CHL",   sd_x = "se_CHL",   xlab = expression(Chl~a~(mg~m^{-3}))),
  list(x = "mean_PAR",   sd_x = "se_PAR",   xlab = expression(PAR~(mu*mol~m^{-2}~s^{-1}))),
  list(x = "mean_PHYTO", sd_x = "se_PHYTO", xlab = "Median phytoplankton size (µm³)")
)

build_env_panels_for_response <- function(df, y, sd_y, ylab) {
  lapply(env_specs, function(e) {
    plot_site_lm_safe(df, e$x, y, e$sd_x, sd_y, e$xlab, ylab)
  })
}

.use_patchwork <- requireNamespace("patchwork", quietly = TRUE)
if (!.use_patchwork && !requireNamespace("gridExtra", quietly = TRUE)) {
  stop("Install 'patchwork' or 'gridExtra' to arrange multi-panel plots.")
}

assemble_env_grid <- function(panels, title_text) {
  if (.use_patchwork) {
    library(patchwork)
    ((panels[[1]] | panels[[2]] | panels[[3]]) /
     (panels[[4]] | panels[[5]] | patchwork::plot_spacer())) +
      plot_annotation(
        title = title_text,
        theme = theme(plot.title = element_text(size = 18, face = "bold", hjust = 0.5))
      )
  } else {
    gridExtra::grid.arrange(
      grobs = panels,
      ncol = 3,
      top = grid::textGrob(title_text, gp = grid::gpar(fontsize = 18, fontface = "bold"))
    )
  }
}

# --- Ordered responses: Mass → Volume → Density → Macroboring → Grazing → Accretion
# (Assumes siteStatsEnv includes mean/se for these response vars and all env vars)

# ΔMass
panels_dm <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanDeltaMass", sd_y = "seDeltaMass",
  ylab = expression(Delta~Mass~(mg~cm^{-2}~y^{-1}))
)
DeltaMass_env_grid <- assemble_env_grid(panels_dm, expression(Delta~Mass~" vs Environmental Drivers"))

# ΔVolume
panels_dv <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanDeltaVolume", sd_y = "seDeltaVolume",
  ylab = expression(Delta~Volume~(mm^3~cm^{-2}~y^{-1}))
)
DeltaVolume_env_grid <- assemble_env_grid(panels_dv, expression(Delta~Volume~" vs Environmental Drivers"))

# ΔDensity
panels_dd <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanDeltaDensity", sd_y = "seDeltaDensity",
  ylab = expression(Delta~Density~(mg~cm^{-3}~cm^{-2}~y^{-1}))
)
DeltaDensity_env_grid <- assemble_env_grid(panels_dd, expression(Delta~Density~" vs Environmental Drivers"))

# Macroboring
panels_mb <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanMacroboring", sd_y = "seMacroboring",
  ylab = expression(Macroboring~(mm^3~cm^{-2}~y^{-1}))
)
Macroboring_env_grid <- assemble_env_grid(panels_mb, expression(Macroboring~" vs Environmental Drivers"))

# Grazing
panels_graze <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanGrazing", sd_y = "seGrazing",
  ylab = expression(Grazing~(mm^3~cm^{-2}~y^{-1}))
)
Grazing_env_grid <- assemble_env_grid(panels_graze, expression(Grazing~" vs Environmental Drivers"))

# Accretion
panels_acc <- build_env_panels_for_response(
  siteStatsEnv,
  y = "meanAccretion", sd_y = "seAccretion",
  ylab = expression(Accretion~(mm^3~cm^{-2}~y^{-1}))
)
Accretion_env_grid <- assemble_env_grid(panels_acc, expression(Accretion~" vs Environmental Drivers"))

# --- Render all in R Markdown -----------------------------------------------
DeltaMass_env_grid
DeltaVolume_env_grid
DeltaDensity_env_grid
Macroboring_env_grid
Grazing_env_grid
Accretion_env_grid
```

# Multivariate analysis
```{r, multivariateAnalysis, echo=FALSE}
vars <- c(
  "deltaDensity_mgcm3cm2y",
  "macroboring_mm3cm2y",
  "accretion_mm3cm2y",
  "grazing_mm3cm2y"
)

# Aggregate to one row per site ----
site_df <- barData %>%
  select(loc1.2, all_of(vars)) %>%
  mutate(across(all_of(vars), as.numeric)) %>%
  drop_na(loc1.2, all_of(vars)) %>%
  group_by(loc1.2) %>%
  summarise(across(all_of(vars), \(x) mean(x, na.rm = TRUE)), .groups = "drop")

# NMDS
X <- site_df %>% select(all_of(vars)) %>% as.data.frame()
rownames(X) <- site_df$loc1.2

X_scaled <- vegan::decostand(X, method = "standardize")

set.seed(42)
nmds <- metaMDS(
  X_scaled,
  distance = "bray",
  k = 2,
  trymax = 200,
  autotransform = FALSE,
  trace = FALSE
)

fit <- envfit(nmds, X_scaled, permutations = 999)

scores_sites <- scores(nmds, display = "sites") %>%
  as.data.frame() %>%
  rownames_to_column("loc1.2")

scores_vec <- scores(fit, display = "vectors") %>%
  as.data.frame() %>%
  rownames_to_column("var")

# Unsupervised clustering on NMDS coords 
# Set k_clusters to an integer to force # clusters; set to NULL to auto-pick (2..6)
k_clusters <- NULL

coords <- scores_sites %>% select(NMDS1, NMDS2)

choose_k_by_silhouette <- function(mat, k_min = 2, k_max = 6) {
  ds <- dist(mat)
  best_k <- k_min
  best_sil <- -Inf
  for (k in k_min:k_max) {
    set.seed(1)
    km <- kmeans(mat, centers = k, nstart = 50)
    sil <- silhouette(km$cluster, ds)
    avg_sil <- mean(sil[, "sil_width"])
    if (avg_sil > best_sil) {
      best_sil <- avg_sil
      best_k <- k
    }
  }
  best_k
}

if (is.null(k_clusters)) {
  k_clusters <- choose_k_by_silhouette(coords, 2, 6)
}

set.seed(1)
km <- kmeans(coords, centers = k_clusters, nstart = 100)
scores_sites$cluster <- factor(km$cluster)

# Convex hulls by cluster ----
hulls <- scores_sites %>%
  group_by(cluster) %>%
  slice(chull(NMDS1, NMDS2))

# Plot with site colors + big vectors + cluster hulls
arrow_mult <- 2.0

p <- ggplot(scores_sites, aes(NMDS1, NMDS2)) +
  # Hull fills (cluster similarity)
  geom_polygon(
    data = hulls,
    aes(group = cluster, fill = cluster),
    alpha = 0.18, color = NA
  ) +
  geom_path(
    data = hulls,
    aes(group = cluster, linetype = cluster),
    linewidth = 1, alpha = 0.9, color = "grey20"
  ) +
  # Sites (keep your per-site colors)
  geom_point(aes(color = loc1.2), size = 4) +
  geom_text_repel(aes(label = loc1.2, color = loc1.2), size = 3, max.overlaps = 200) +
  scale_color_manual(values = loc_colors, guide = "none") +
  # Vectors
  geom_segment(
    data = scores_vec,
    aes(x = 0, y = 0, xend = NMDS1 * arrow_mult, yend = NMDS2 * arrow_mult),
    arrow = arrow(length = unit(0.03, "npc")),
    linewidth = 1
  ) +
  geom_text_repel(
    data = scores_vec,
    aes(x = NMDS1 * arrow_mult, y = NMDS2 * arrow_mult, label = var),
    size = 4, fontface = "bold"
  ) +
  coord_equal() +
  theme_minimal(base_size = 13) +
  labs(
    title = "NMDS of loc1.2 Sites with Convex Hulls by Similarity",
    subtitle = paste0("Unsupervised clusters (k = ", k_clusters, ") on NMDS scores; Bray–Curtis; variables standardized"),
    x = "NMDS1", y = "NMDS2",
    fill = "Cluster", linetype = "Cluster"
  ) +
  theme(plot.title = element_text(face = "bold"))

print(p)

# Diagnostics
nmds$stress
```
Stress = `r nmds$stress`

# Human pressure/proximity analysis
## Calculate human pressure statistics
Distance to coastline, port, city, or nearest port/city
```{r, distanceToFeatureCalculations, echo=FALSE}

barHumanStats <- barStatsLoc3 %>%
  select(loc3, latitude, longitude, basin) %>%
  distinct()
# Sites to sf
loc3_sf <- barHumanStats %>%
  filter(!is.na(latitude), !is.na(longitude)) %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)

# Natural Earth layers
coastline <- ne_download(scale = 10, type = "coastline", category = "physical",  returnclass = "sf")
ports     <- ne_download(scale = 10, type = "ports",     category = "cultural",  returnclass = "sf")
cities    <- ne_download(scale = 10, type = "populated_places", category = "cultural", returnclass = "sf")

# Distance calculations
# 1) Distance to nearest coastline (km)
dist_coast_m  <- st_distance(loc3_sf, coastline)               # matrix (n_sites x n_coast_segments)
dist_coast_km <- apply(dist_coast_m, 1, min) / 1000            # row-wise min, convert m -> km

# Distance to nearest port (km)
nearest_port_idx <- st_nearest_feature(loc3_sf, ports)         # index of nearest port per site
dist_port_km     <- as.numeric(st_distance(loc3_sf, ports[nearest_port_idx,], by_element = TRUE)) / 1000

# Distance to nearest city (km)
nearest_city_idx <- st_nearest_feature(loc3_sf, cities)
dist_city_km     <- as.numeric(st_distance(loc3_sf, cities[nearest_city_idx,], by_element = TRUE)) / 1000

# Minimum distance (port or city)
dist_human_access_km <- pmin(dist_port_km, dist_city_km, na.rm = TRUE)

# Append to table
barHumanStats <- loc3_sf %>%
  st_drop_geometry() %>%
  mutate(
    dist_coast_km        = dist_coast_km,
    dist_port_km         = dist_port_km,
    dist_city_km         = dist_city_km,
    dist_human_access_km = dist_human_access_km
  )

```

Population within a set radius
Data from: https://search.earthdata.nasa.gov/search?q=CIESIN%20ESDIS
```{r, echo=FALSE}
#Ian's work computer
tif_path <- file.path("C:/Users/ian.enochs/Documents/projects/globar/gpw_v4_population_count_adjusted_to_2015_unwpp_country_totals_rev11_2020_30_sec.tif")

#John's work computer
if (!file.exists(tif_path)) {
  tif_path <- file.path("/Users/john.morris/Desktop/BMUs/populations/gpw_v4_population_count_adjusted_to_2015_unwpp_country_totals_rev11_2020_30_sec.tif")
}


# Expect: barHumanStats with loc3, latitude, longitude
stopifnot(all(c("loc3","latitude","longitude") %in% names(barHumanStats)))

# Radii (km)
radii_km <- c(5, 10, 50, 100)

# Load raster *without* replacing NA with 0
r <- rast(tif_path)

# Geodesic points
sf_use_s2(TRUE)
pts <- st_as_sf(barHumanStats, coords = c("longitude","latitude"), crs = 4326, remove = FALSE)

# Speed options
USE_EXACT <- FALSE   # exact overlap calculation? (set TRUE if needed, but slower)
N_QUAD_SEGS <- 8     # simplifies buffer polygon geometry for speed

extract_pop_sum_km <- function(radius_km) {
  bufs <- st_buffer(pts, dist = radius_km * 1000, nQuadSegs = N_QUAD_SEGS)
  bufs_v <- vect(bufs)

  # Crop raster extent first for big speed gain
  r_crop <- crop(r, ext(bufs_v))

  # exact = FALSE → cell-center test only (fast)
  # no NA→0 replacement → result truly NA if no valid land/pop pixels
  ext_df <- terra::extract(r_crop, bufs_v, fun = sum, na.rm = TRUE, exact = USE_EXACT)

  # Take the numeric result column directly
  ext_df[[ncol(ext_df)]]
}

# Loop over each desired radius
for (rk in radii_km) {
  colname <- sprintf("population_%dkm_2005", rk)
  barHumanStats[[colname]] <- extract_pop_sum_km(rk)
}

for (rk in radii_km) {
  colname <- sprintf("population_%dkm_2005", rk)
  barHumanStats[[colname]][is.nan(barHumanStats[[colname]])] <- 0
}
```

Display human pressure statistics table
```{r, showHumanStatsTable, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
kbl(barHumanStats, , digits = 4, caption = "Human pressure statistics by loc3") %>%
  kable_classic(full_width = FALSE, html_font = "Cambria") %>%
  add_header_above(c(
    "location" = 4, "distance" = 4,
    "population" = 4)) %>%
  scroll_box(width = "1200px")

```

## Human pressure graphs
### Human pressure by loc3
```{r, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
# ========= 1) Join & ensure `loc1.2` =========
pop_cols <- c(
  "population_5km_2005","population_10km_2005",
  "population_50km_2005","population_100km_2005"
)

barLoc3_merged <- barStatsLoc3 %>%
  dplyr::left_join(
    barHumanStats %>%
      dplyr::select(
        loc3,
        dist_port_km, dist_city_km, dist_coast_km, dist_human_access_km,
        dplyr::any_of(pop_cols)
      ),
    by = "loc3"
  )

# Ensure a clean `loc1.2` for coloring
if (!"loc1.2" %in% names(barLoc3_merged)) {
  if (any(c("loc1.2.x","loc1.2.y") %in% names(barLoc3_merged))) {
    barLoc3_merged <- barLoc3_merged %>%
      dplyr::mutate(`loc1.2` = dplyr::coalesce(.data[["loc1.2.x"]], .data[["loc1.2.y"]])) %>%
      dplyr::select(-dplyr::any_of(c("loc1.2.x","loc1.2.y")))
  } else if ("loc1_2" %in% names(barLoc3_merged)) {
    barLoc3_merged <- barLoc3_merged %>% dplyr::rename(`loc1.2` = loc1_2)
  } else {
    barLoc3_merged <- barLoc3_merged %>%
      dplyr::mutate(`loc1.2` = as.character(loc3))
    message("`loc1.2` not found; using loc3 as a fallback for coloring.")
  }
}

# Convert NaN -> 0 ONLY for population columns (keep true NA as NA); no logs
for (pc in intersect(pop_cols, names(barLoc3_merged))) {
  if (is.numeric(barLoc3_merged[[pc]])) {
    barLoc3_merged[[pc]][is.nan(barLoc3_merged[[pc]])] <- 0
  }
}

# ========= 2) Response variables & long format =========
response_map <- c(
  mass        = "meanDeltaMass",
  volume      = "meanDeltaVolume",
  macroboring = "meanMacroboring",
  grazing     = "meanGrazing",
  accretion   = "meanAccretion"
)

long_dat <- barLoc3_merged %>%
  dplyr::select(
    loc3, `loc1.2`, basin,
    dplyr::any_of(unname(response_map)),
    dist_port_km, dist_city_km, dist_coast_km, dist_human_access_km,
    dplyr::any_of(pop_cols)
  ) %>%
  tidyr::pivot_longer(
    cols = dplyr::any_of(unname(response_map)),
    names_to = "response_col",
    values_to = "response_value"
  ) %>%
  dplyr::mutate(
    metric = dplyr::recode(response_col, !!!setNames(names(response_map), response_map)),
    response_value = suppressWarnings(as.numeric(response_value)),
    basin = tolower(as.character(basin))
  )

# ========= 3) Helpers for multi-basin fits =========
interpret_model <- function(R2, p) {
  if (is.na(R2) || is.na(p)) return("insufficient data")
  if (p >= 0.05) return("not significant")
  if (R2 < 0.10) return("weak but significant")
  if (R2 < 0.30) return("moderate")
  "strong"
}

# Build long data with three "fit groups":
#  - All data (no basin filter)
#  - Atlantic only
#  - Pacific only
make_basin_fit_data <- function(df, xvar) {
  df_base <- df %>% filter(!is.na(response_value))

  bind_rows(
    df_base %>%
      mutate(fit_group = "All data"),
    df_base %>%
      filter(basin == "atlantic") %>%
      mutate(fit_group = "Atlantic"),
    df_base %>%
      filter(basin == "pacific") %>%
      mutate(fit_group = "Pacific")
  ) %>%
    filter(!is.na(.data[[xvar]]))
}

facet_lm_stats_basin <- function(df, xvar) {
  df_long <- make_basin_fit_data(df, xvar)

  df_long %>%
    dplyr::group_by(metric, fit_group) %>%
    dplyr::reframe({
      x <- suppressWarnings(as.numeric(.data[[xvar]]))
      y <- suppressWarnings(as.numeric(response_value))
      n <- sum(stats::complete.cases(x, y))

      ok <- (n > 2) &&
        is.finite(stats::var(x, na.rm = TRUE)) && stats::var(x, na.rm = TRUE) > 0 &&
        is.finite(stats::var(y, na.rm = TRUE)) && stats::var(y, na.rm = TRUE) > 0

      if (ok) {
        fit <- stats::lm(y ~ x)
        s   <- summary(fit)
        R2    <- unname(s$r.squared)
        p     <- unname(s$coefficients[2, 4])
        slope <- unname(stats::coef(fit)[2])
      } else {
        R2 <- NA_real_; p <- NA_real_; slope <- NA_real_
      }

      x_min <- suppressWarnings(min(x, na.rm = TRUE))
      x_max <- suppressWarnings(max(x, na.rm = TRUE))
      y_min <- suppressWarnings(min(y, na.rm = TRUE))
      y_max <- suppressWarnings(max(y, na.rm = TRUE))

      xr <- if (is.finite(x_max - x_min)) x_max - x_min else 0
      yr <- if (is.finite(y_max - y_min)) y_max - y_min else 0

      x_pos <- x_min + (if (xr == 0) 0.02 * (if (x_max == 0) 1 else abs(x_max)) else 0.02 * xr)
      y_pos <- y_max - (if (yr == 0) 0.02 * (if (y_max == 0) 1 else abs(y_max)) else 0.02 * yr)

      interp <- interpret_model(R2, p)
      label <- paste0(
        "R² = ", ifelse(is.na(R2), "NA", sprintf("%.2f", R2)),
        ", p = ", ifelse(is.na(p), "NA", formatC(p, format = "e", digits = 2)),
        ", n = ", n,
        "\nslope = ", ifelse(is.na(slope), "NA", formatC(slope, format = "g", digits = 3)),
        "  (", interp, ")"
      )

      tibble(x_pos = x_pos, y_pos = y_pos, label = label)
    })
}

plot_response_vs_x_basin <- function(df, xvar, x_label, title_text) {
  df_long <- make_basin_fit_data(df, xvar)
  labs_df <- facet_lm_stats_basin(df, xvar)

  ggplot(df_long, aes(x = .data[[xvar]], y = response_value)) +
    geom_point(aes(color = factor(`loc1.2`)), alpha = 0.85) +
    scale_color_manual(values = loc_colors) +
    geom_smooth(
      aes(group = 1),
      method = "lm", se = TRUE, color = "black"
    ) +
    facet_grid(fit_group ~ metric, scales = "free_y") +
    geom_text(
      data = labs_df,
      aes(x = x_pos, y = y_pos, label = label),
      inherit.aes = FALSE,
      hjust = 0, vjust = 1, size = 3
    ) +
    labs(
      title = title_text,
      x = x_label,
      y = NULL
    ) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(face = "bold"),
      strip.text = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    )
}

# ========= 4) Distance-based plots with 3 regressions each =========

plot_city <- long_dat %>%
  mutate(dist_city_km = suppressWarnings(as.numeric(dist_city_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_city_km",
    x_label    = "Distance to city (km)",
    title_text = "Distance to City vs. Reef Metrics (All / Atlantic / Pacific fits)"
  )

plot_port <- long_dat %>%
  mutate(dist_port_km = suppressWarnings(as.numeric(dist_port_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_port_km",
    x_label    = "Distance to port (km)",
    title_text = "Distance to Port vs. Reef Metrics (All / Atlantic / Pacific fits)"
  )

plot_coast <- long_dat %>%
  mutate(dist_coast_km = suppressWarnings(as.numeric(dist_coast_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_coast_km",
    x_label    = "Distance to coast (km)",
    title_text = "Distance to Coast vs. Reef Metrics (All / Atlantic / Pacific fits)"
  )

plot_access <- long_dat %>%
  mutate(dist_human_access_km = suppressWarnings(as.numeric(dist_human_access_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_human_access_km",
    x_label    = "Distance to human access (km)",
    title_text = "Distance to Human Access vs. Reef Metrics (All / Atlantic / Pacific fits)"
  )

# ========= 5) Population-based plots (raw, 3 regressions each) =========

make_pop_plot_raw <- function(raw_col, label_km) {
  if (!raw_col %in% names(long_dat)) return(NULL)

  pretty_label <- sprintf("Population within %s (2005)", label_km)

  long_dat %>%
    mutate(!!raw_col := suppressWarnings(as.numeric(.data[[raw_col]]))) %>%
    plot_response_vs_x_basin(
      xvar       = raw_col,
      x_label    = pretty_label,
      title_text = paste0(
        pretty_label,
        " vs. Reef Metrics (All / Atlantic / Pacific fits)"
      )
    )
}

plot_pop5   <- make_pop_plot_raw("population_5km_2005",   "5 km")
plot_pop10  <- make_pop_plot_raw("population_10km_2005",  "10 km")
plot_pop50  <- make_pop_plot_raw("population_50km_2005",  "50 km")
plot_pop100 <- make_pop_plot_raw("population_100km_2005", "100 km")

# ========= 6) Print all plots =========
print(plot_city)
print(plot_port)
print(plot_coast)
print(plot_access)

if (!is.null(plot_pop5))   print(plot_pop5)   else message("population_5km_2005 not found—skipping plot.")
if (!is.null(plot_pop10))  print(plot_pop10)  else message("population_10km_2005 not found—skipping plot.")
if (!is.null(plot_pop50))  print(plot_pop50)  else message("population_50km_2005 not found—skipping plot.")
if (!is.null(plot_pop100)) print(plot_pop100) else message("population_100km_2005 not found—skipping plot.")
```

### Human pressure all points
```{r, humanImpactGraphsAllPoints, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}
# ====== 0) Packages ======
suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(rlang)
  library(tibble)
  library(stringr)
  library(ggh4x)   # <- enables per-panel y-axes in facet_grid layout
})

# ====== 1) Join barData to human stats at loc3, ensure loc1.2 & basin ======
pop_cols <- c("population_5km_2005","population_10km_2005",
              "population_50km_2005","population_100km_2005")

barLoc3_merged <- barData %>%
  dplyr::left_join(
    barHumanStats %>%
      dplyr::select(
        loc3,
        dist_port_km, dist_city_km, dist_coast_km, dist_human_access_km,
        dplyr::any_of(pop_cols)
      ),
    by = "loc3"
  )

# Ensure a clean `loc1.2` for coloring
if (!"loc1.2" %in% names(barLoc3_merged)) {
  if (any(c("loc1.2.x","loc1.2.y") %in% names(barLoc3_merged))) {
    barLoc3_merged <- barLoc3_merged %>%
      dplyr::mutate(`loc1.2` = dplyr::coalesce(.data[["loc1.2.x"]], .data[["loc1.2.y"]])) %>%
      dplyr::select(-dplyr::any_of(c("loc1.2.x","loc1.2.y")))
  } else if ("loc1_2" %in% names(barLoc3_merged)) {
    barLoc3_merged <- barLoc3_merged %>% dplyr::rename(`loc1.2` = loc1_2)
  } else if (all(c("loc1","loc2") %in% names(barLoc3_merged))) {
    barLoc3_merged <- barLoc3_merged %>%
      dplyr::mutate(`loc1.2` = if_else(is.na(loc2) | loc2 == "", loc1, paste0(loc1, ".", loc2)))
  } else {
    barLoc3_merged <- barLoc3_merged %>%
      dplyr::mutate(`loc1.2` = as.character(loc3))
    message("`loc1.2` not found; using loc3 as a fallback for coloring.")
  }
}

# Convert NaN -> 0 ONLY for population columns (keep real NA as NA)
for (pc in intersect(pop_cols, names(barLoc3_merged))) {
  if (is.numeric(barLoc3_merged[[pc]])) {
    barLoc3_merged[[pc]][is.nan(barLoc3_merged[[pc]])] <- 0
  }
}

# Ensure basin exists & normalize
if (!"basin" %in% names(barLoc3_merged)) {
  barLoc3_merged$basin <- NA_character_
}
barLoc3_merged$basin <- tolower(as.character(barLoc3_merged$basin))

# ====== 2) Responses (from barData) & long format ======
responses <- c(
  accretion_mm3cm2y      = "accretion",
  grazing_mm3cm2y        = "grazing",
  macroboring_mm3cm2y    = "macroboring",
  deltaMass_mgcm2y       = "mass",
  deltaVolume_mm3cm2y    = "volume"
)

long_dat <- barLoc3_merged %>%
  dplyr::select(
    loc3, `loc1.2`, basin,
    dplyr::any_of(names(responses)),
    dist_port_km, dist_city_km, dist_coast_km, dist_human_access_km,
    dplyr::any_of(pop_cols)
  ) %>%
  tidyr::pivot_longer(
    cols = dplyr::any_of(names(responses)),
    names_to = "response_col", values_to = "response_value"
  ) %>%
  dplyr::mutate(
    metric = dplyr::recode(response_col, !!!setNames(unname(responses), names(responses))),
    response_value = suppressWarnings(as.numeric(response_value)),
    metric = factor(metric, levels = unname(responses))  # lock 5 columns order
  )

# ====== 3) Helpers for multi-basin fits (All / Atlantic / Pacific) ======
interpret_model <- function(R2, p) {
  if (is.na(R2) || is.na(p)) return("insufficient data")
  if (p >= 0.05) return("not significant")
  if (R2 < 0.10) return("weak but significant")
  if (R2 < 0.30) return("moderate")
  "strong"
}

make_basin_fit_data <- function(df, xvar) {
  df_base <- df %>% filter(!is.na(response_value))
  bind_rows(
    df_base %>% mutate(fit_group = "All data"),
    df_base %>% filter(basin == "atlantic") %>% mutate(fit_group = "Atlantic"),
    df_base %>% filter(basin == "pacific")  %>% mutate(fit_group = "Pacific")
  ) %>%
    filter(!is.na(.data[[xvar]])) %>%
    mutate(fit_group = factor(fit_group, levels = c("All data","Atlantic","Pacific"))) # lock 3 rows order
}

facet_lm_stats_basin <- function(df, xvar) {
  df_long <- make_basin_fit_data(df, xvar)

  df_long %>%
    dplyr::group_by(metric, fit_group) %>%
    dplyr::reframe({
      x <- suppressWarnings(as.numeric(.data[[xvar]]))
      y <- suppressWarnings(as.numeric(response_value))
      n <- sum(stats::complete.cases(x, y))

      ok <- (n > 2) &&
        is.finite(stats::var(x, na.rm = TRUE)) && stats::var(x, na.rm = TRUE) > 0 &&
        is.finite(stats::var(y, na.rm = TRUE)) && stats::var(y, na.rm = TRUE) > 0

      if (ok) {
        fit <- stats::lm(y ~ x)
        s   <- summary(fit)
        R2    <- unname(s$r.squared)
        p     <- unname(s$coefficients[2, 4])
        slope <- unname(stats::coef(fit)[2])
      } else {
        R2 <- NA_real_; p <- NA_real_; slope <- NA_real_
      }

      x_min <- suppressWarnings(min(x, na.rm = TRUE))
      x_max <- suppressWarnings(max(x, na.rm = TRUE))
      y_min <- suppressWarnings(min(y, na.rm = TRUE))
      y_max <- suppressWarnings(max(y, na.rm = TRUE))

      xr <- if (is.finite(x_max - x_min)) x_max - x_min else 0
      yr <- if (is.finite(y_max - y_min)) y_max - y_min else 0

      x_pos <- x_min + (if (xr == 0) 0.02 * (if (x_max == 0) 1 else abs(x_max)) else 0.02 * xr)
      y_pos <- y_max - (if (yr == 0) 0.02 * (if (y_max == 0) 1 else abs(y_max)) else 0.02 * yr)

      interp <- interpret_model(R2, p)
      label <- paste0(
        "R² = ", ifelse(is.na(R2), "NA", sprintf("%.2f", R2)),
        ", p = ", ifelse(is.na(p), "NA", formatC(p, format = "e", digits = 2)),
        ", n = ", n,
        "\nslope = ", ifelse(is.na(slope), "NA", formatC(slope, format = "g", digits = 3)),
        "  (", interp, ")"
      )

      is_sig <- !is.na(p) && p < 0.05
      text_col <- if (is_sig) "#1B9E77" else "grey20"

      tibble(x_pos = x_pos, y_pos = y_pos, label = label, text_col = text_col)
    })
}

# ====== 4) Plot function (5×3 grid; truly per-panel y using ggh4x) ======
plot_response_vs_x_basin <- function(df, xvar, x_label, title_text) {
  df_long <- make_basin_fit_data(df, xvar)
  labs_df <- facet_lm_stats_basin(df, xvar)

  color_scale <- if (exists("loc_colors", inherits = TRUE)) {
    scale_color_manual(values = loc_colors)
  } else {
    scale_color_discrete()
  }

  ggplot(df_long, aes(x = .data[[xvar]], y = response_value)) +
    geom_point(aes(color = factor(`loc1.2`)), alpha = 0.85) +
    color_scale +
    geom_smooth(aes(group = 1), method = "lm", se = TRUE, color = "black") +
    # >>> Keep 5 columns (metrics) × 3 rows (fit_group) WITH independent y per panel <<<
    ggh4x::facet_grid2(
      rows  = vars(fit_group),
      cols  = vars(metric),
      scales = "free_y",
      independent = "y"  # <- per-panel y-axes (not shared within rows)
    ) +
    geom_text(
      data = labs_df,
      aes(x = x_pos, y = y_pos, label = label, color = I(text_col)),
      inherit.aes = FALSE, hjust = 0, vjust = 1, size = 3
    ) +
    labs(title = title_text, x = x_label, y = NULL) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(face = "bold"),
      strip.text = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      legend.position = "none"
    )
}

# ====== 5) Distance-based plots (x = human distances; y = bar responses) ======
plot_city <- long_dat %>%
  mutate(dist_city_km = suppressWarnings(as.numeric(dist_city_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_city_km",
    x_label    = "Distance to city (km)",
    title_text = "Distance to City vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

plot_port <- long_dat %>%
  mutate(dist_port_km = suppressWarnings(as.numeric(dist_port_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_port_km",
    x_label    = "Distance to port (km)",
    title_text = "Distance to Port vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

plot_coast <- long_dat %>%
  mutate(dist_coast_km = suppressWarnings(as.numeric(dist_coast_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_coast_km",
    x_label    = "Distance to coast (km)",
    title_text = "Distance to Coast vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

plot_access <- long_dat %>%
  mutate(dist_human_access_km = suppressWarnings(as.numeric(dist_human_access_km))) %>%
  plot_response_vs_x_basin(
    xvar       = "dist_human_access_km",
    x_label    = "Distance to human access (km)",
    title_text = "Distance to Human Access vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

# ====== 6) Population-based plots (x = population rings; y = bar responses) ======
make_pop_plot_raw <- function(raw_col, label_km) {
  if (!raw_col %in% names(long_dat)) return(NULL)
  pretty_label <- sprintf("Population within %s (2005)", label_km)

  long_dat %>%
    mutate(!!raw_col := suppressWarnings(as.numeric(.data[[raw_col]]))) %>%
    plot_response_vs_x_basin(
      xvar       = raw_col,
      x_label    = pretty_label,
      title_text = paste0(pretty_label, " vs. Bar Responses (All / Atlantic / Pacific fits)")
    )
}

plot_pop5   <- make_pop_plot_raw("population_5km_2005",   "5 km")
plot_pop10  <- make_pop_plot_raw("population_10km_2005",  "10 km")
plot_pop50  <- make_pop_plot_raw("population_50km_2005",  "50 km")
plot_pop100 <- make_pop_plot_raw("population_100km_2005", "100 km")

# ====== 7) Print all plots ======
print(plot_city)
print(plot_port)
print(plot_coast)
print(plot_access)

if (!is.null(plot_pop5))   print(plot_pop5)   else message("population_5km_2005 not found—skipping plot.")
if (!is.null(plot_pop10))  print(plot_pop10)  else message("population_10km_2005 not found—skipping plot.")
if (!is.null(plot_pop50))  print(plot_pop50)  else message("population_50km_2005 not found—skipping plot.")
if (!is.null(plot_pop100)) print(plot_pop100) else message("population_100km_2005 not found—skipping plot.")

```

### Human pressure as gravity index
```{r gravityIndex, fig.width=12, fig.height=18, out.width="100%", echo=FALSE}

# 1) Read gravity index (just loc3 + totalGravity)
grav_path   <- file.path(data_dir, "BMU_gravityIndex.csv")
gravityData <- readr::read_csv(grav_path, show_col_types = FALSE) %>%
  dplyr::select(loc3, totalGravity)

# 2) Make sure barData has clean 'basin' and 'loc1.2' columns
if (!"basin" %in% names(barData)) {
  if ("basin.x" %in% names(barData)) {
    barData <- barData %>% dplyr::rename(basin = basin.x)
  } else if ("basin.y" %in% names(barData)) {
    barData <- barData %>% dplyr::rename(basin = basin.y)
  }
}

if (!"loc1.2" %in% names(barData)) {
  if ("loc1.2.x" %in% names(barData)) {
    barData <- barData %>% dplyr::rename(`loc1.2` = `loc1.2.x`)
  } else if ("loc1.2.y" %in% names(barData)) {
    barData <- barData %>% dplyr::rename(`loc1.2` = `loc1.2.y`)
  }
}

# 3) Add totalGravity to *each row* of barData via loc3
barData <- barData %>%
  dplyr::left_join(gravityData, by = "loc3")

# 4) Response variables + pretty labels (same style as your barData code)
responses <- c(
  accretion_mm3cm2y      = "accretion",
  grazing_mm3cm2y        = "grazing",
  macroboring_mm3cm2y    = "macroboring",
  deltaMass_mgcm2y       = "mass",
  deltaVolume_mm3cm2y    = "volume"
)

# 5) Build a long data frame JUST for gravity analysis
gravity_long <- barData %>%
  dplyr::select(
    loc3, `loc1.2`, basin,
    dplyr::any_of(names(responses)),
    totalGravity
  ) %>%
  tidyr::pivot_longer(
    cols      = dplyr::any_of(names(responses)),
    names_to  = "response_col",
    values_to = "response_value"
  ) %>%
  dplyr::mutate(
    metric = dplyr::recode(response_col, !!!setNames(unname(responses), names(responses))),
    response_value = suppressWarnings(as.numeric(response_value)),
    metric         = factor(metric, levels = unname(responses)),
    totalGravity   = suppressWarnings(as.numeric(totalGravity)),
    basin          = tolower(as.character(basin))
  )

# ---- 6) Plot with raw gravity ----
plot_gravity <- gravity_long %>%
  plot_response_vs_x_basin(
    xvar       = "totalGravity",
    x_label    = "Total gravity",
    title_text = "Total Gravity vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

print(plot_gravity)

# ---- 7) Plot with log-transformed gravity (log10) ----
gravity_long_log <- gravity_long %>%
  dplyr::mutate(
    log_totalGravity = dplyr::if_else(
      totalGravity > 0,
      log10(totalGravity),
      NA_real_
    )
  )

plot_gravity_log <- gravity_long_log %>%
  plot_response_vs_x_basin(
    xvar       = "log_totalGravity",
    x_label    = "log10(Total gravity)",
    title_text = "log10(Total Gravity) vs. Bar Responses (All / Atlantic / Pacific fits)"
  )

print(plot_gravity_log)
```

# Abstract

The remarkable biodiversity of coral reef is a direct result of complex three-dimensional structures that provides shelter to its inhabitants. This calcium carbonate framework - created by corals - forms the foundation for fundamental goods and services, a natural infrastructure for coastal communities worldwide. Importantly, reef framework, the species that dependent on it and the services we rely on, are threatened by myriad stressors which contribute to the global decline of habitat forming species, all the while accelerating the rate at which habitat is eroded away. Survey-based approaches have been used at regional (REF) and global scales (REF), estimating trajectories that are largely negative and insufficient to keep pace with sea level rise (REF). To date, however, the persistence of reef carbonates has yet to be measured across global scales - a critical knowledge gap that has implications for the countless species that rely on coral reefs, including us. 








